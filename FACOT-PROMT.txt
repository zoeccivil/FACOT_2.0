Actuarás como mi asistente experto en programación Python, especializado en refactorización de código, diseño orientado a objetos, y desarrollo de interfaces gráficas con Pyqt6 y la base de datos SQLite.

Contexto del Proyecto:

Nuestro objetivo es tartar de hacer un programa nuevo de generacion de facturas y cotizaciones basado en unos archivos que te voy a enviar y leyendo datos desde una base de datos existente y utilizando archivos base que tengo y mejorarlo, lo que quiero es que una vez generemos facturas se marquen automaticamente en la base de datos y que se actualice en el programa de facturas que ya funciona.

Los archivos que utilzamos para la creacion de facturas y de llenado de plantillas son, Invoice_filler.py, Invoice_generator_window.py


### Archivo: main.py

import tkinter as tk
from tkinter import filedialog, messagebox
from ttkthemes import ThemedTk
from app_gui import MainApplication
from logic import LogicController
import config_manager
import os

def get_database_path():
    """
    Obtiene la ruta de la base de datos desde config.
    Si no hay, o el archivo no existe, pregunta al usuario y guarda la ruta seleccionada.
    """
    config = config_manager.load_config()
    db_path = config.get("database_path")

    # Si la ruta existe y el archivo existe, úsala
    if db_path and os.path.exists(db_path):
        return db_path

    # Si no existe, pregunta al usuario
    root_temp = tk.Tk()
    root_temp.withdraw()
    db_path = filedialog.askopenfilename(
        title="Selecciona tu archivo de Base de Datos (.db)",
        filetypes=[("Base de Datos SQLite", "*.db"), ("Todos los archivos", "*.*")]
    )
    root_temp.destroy()

    if not db_path:
        messagebox.showinfo("Sin Base de Datos", "No seleccionaste ningún archivo de base de datos. La aplicación se cerrará.")
        return None

    if not os.path.exists(db_path):
        messagebox.showerror("Error", f"El archivo de base de datos seleccionado no existe:\n{db_path}")
        return None

    if not os.access(db_path, os.R_OK | os.W_OK):
        messagebox.showerror("Error", "No tienes permisos de lectura/escritura sobre el archivo de base de datos seleccionado.")
        return None

    # Guarda la ruta en config para próximos inicios
    config_manager.set_db_path(db_path)

    return db_path

def main():
    """Punto de entrada principal de la aplicación."""
    db_path = get_database_path()

    if not db_path:
        print("No se seleccionó una base de datos. Cerrando aplicación.")
        return

    try:
        root = ThemedTk(theme="arc")
        logic_controller = LogicController(db_path)
        app = MainApplication(root, logic_controller)
        root.mainloop()
    except Exception as e:
        messagebox.showerror("Error Fatal", f"Ocurrió un error fatal al iniciar la aplicación: {e}")

if __name__ == "__main__":
    main()

### Archivo: logic.py

import sqlite3
import os
import json
import datetime
import re
from utils import find_dropbox_folder
from sqlite3 import IntegrityError
import config_manager
import tkinter as tk
from tkinter import filedialog, messagebox

class LogicController:
    """
    Maneja toda la lógica de negocio y la interacción con la base de datos.
    """

    def __init__(self, db_path):
        self.db_path = db_path
        self.conn = None
        self._connect()
        self._initialize_db()

    # === HELPERS DE EMPRESA ===
    def get_company_by_name(self, name: str):
        if not self.conn: return None
        cur = self.conn.cursor()
        cur.execute("SELECT id, name FROM companies WHERE name = ?", (name,))
        return cur.fetchone()

    def get_single_company_id_or_none(self):
        if not self.conn: return None
        cur = self.conn.cursor()
        cur.execute("SELECT id FROM companies LIMIT 2")
        rows = cur.fetchall()
        if len(rows) == 1:
            try:
                return int(rows[0][0])
            except Exception:
                return None
        return None

    def get_invoice_company_id(self, invoice_id: int):
        if not self.conn: return None
        cur = self.conn.cursor()
        cur.execute("SELECT company_id FROM invoices WHERE id = ?", (invoice_id,))
        row = cur.fetchone()
        if row:
            try:
                return int(row["company_id"])
            except Exception:
                try:
                    return int(row[0])
                except Exception:
                    return None
        return None

    def _connect(self):
        """Establece la conexión a la base de datos SQLite."""
        try:
            self.conn = sqlite3.connect(self.db_path)
            self.conn.row_factory = sqlite3.Row
            print("Conexión a la base de datos establecida exitosamente.")
        except sqlite3.Error as e:
            print(f"Error al conectar con la base de datos: {e}")
            self.conn = None

    def _initialize_db(self):
        """
        Crea/migra todas las tablas e índices necesarios de forma segura (idempotente).
        Activa claves foráneas y siembra datos básicos (monedas).
        """
        if not self.conn:
            return
        cur = self.conn.cursor()

        # Activar FK
        cur.execute("PRAGMA foreign_keys = ON;")

        # === BASE ===
        cur.execute("""
            CREATE TABLE IF NOT EXISTS companies (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL,
                rnc TEXT UNIQUE NOT NULL,
                address TEXT,
                invoice_template_path TEXT,
                invoice_output_base_path TEXT,
                itbis_adelantado REAL DEFAULT 0.0,
                legacy_filename TEXT
            )
        """)

        cur.execute("""
            CREATE TABLE IF NOT EXISTS settings (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        """)

        cur.execute("""
            CREATE TABLE IF NOT EXISTS third_parties (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                rnc TEXT UNIQUE NOT NULL,
                name TEXT NOT NULL
            )
        """)

        cur.execute("""
            CREATE TABLE IF NOT EXISTS invoices (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                company_id INTEGER NOT NULL,
                invoice_type TEXT NOT NULL,
                invoice_date TEXT NOT NULL,
                imputation_date TEXT,
                invoice_number TEXT NOT NULL,
                invoice_category TEXT,
                rnc TEXT NOT NULL,
                third_party_name TEXT NOT NULL,
                currency TEXT NOT NULL,
                itbis REAL NOT NULL DEFAULT 0.0,
                total_amount REAL NOT NULL DEFAULT 0.0,
                exchange_rate REAL NOT NULL DEFAULT 1.0,
                total_amount_rd REAL NOT NULL DEFAULT 0.0,
                attachment_path TEXT,
                FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE CASCADE
            )
        """)

        cur.execute("""
            CREATE TABLE IF NOT EXISTS invoice_items (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                invoice_id INTEGER NOT NULL,
                description TEXT NOT NULL,
                quantity REAL NOT NULL DEFAULT 0.0,
                unit_price REAL NOT NULL DEFAULT 0.0,
                FOREIGN KEY (invoice_id) REFERENCES invoices(id) ON DELETE CASCADE
            )
        """)

        cur.execute("""
            CREATE UNIQUE INDEX IF NOT EXISTS idx_unique_invoice
            ON invoices (company_id, rnc, invoice_number)
        """)

        cur.execute("""
            CREATE TABLE IF NOT EXISTS currencies (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT UNIQUE NOT NULL
            )
        """)

        cur.execute("SELECT COUNT(*) FROM currencies")
        count = cur.fetchone()[0]
        if count == 0:
            cur.executemany("INSERT INTO currencies (name) VALUES (?)", [("RD$",), ("USD",)])

        cur.execute("""
            CREATE TABLE IF NOT EXISTS tax_calculations (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                company_id INTEGER NOT NULL,
                name TEXT NOT NULL,
                created_at TEXT NOT NULL,
                percent_to_pay REAL NOT NULL,
                notes TEXT,
                start_date TEXT,
                end_date TEXT,
                FOREIGN KEY (company_id) REFERENCES companies(id) ON DELETE CASCADE
            )
        """)

        cur.execute("""
            CREATE TABLE IF NOT EXISTS tax_calculation_details (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                calculation_id INTEGER NOT NULL,
                invoice_id INTEGER NOT NULL,
                include_in_final INTEGER NOT NULL DEFAULT 1,
                sort_order INTEGER NOT NULL DEFAULT 0,
                itbis_retention_applied INTEGER DEFAULT 0,
                FOREIGN KEY (calculation_id) REFERENCES tax_calculations(id) ON DELETE CASCADE,
                FOREIGN KEY (invoice_id) REFERENCES invoices(id) ON DELETE CASCADE
            )
        """)

        cur.execute("CREATE INDEX IF NOT EXISTS idx_invoices_company_date ON invoices(company_id, invoice_date)")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_invoices_rnc ON invoices(rnc)")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_items_invoice ON invoice_items(invoice_id)")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_tax_calc_company ON tax_calculations(company_id)")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_tax_calc_details_calc ON tax_calculation_details(calculation_id)")
        cur.execute("CREATE INDEX IF NOT EXISTS idx_tax_calc_details_invoice ON tax_calculation_details(invoice_id)")

        self.conn.commit()

    def save_tax_calculation(self, calc_id, company_id, name, start_date, end_date, percent, details):
        """Guarda o actualiza una configuración de cálculo de impuestos."""
        try:
            cursor = self.conn.cursor()
            cursor.execute("BEGIN TRANSACTION")
            if calc_id:
                cursor.execute("""
                    UPDATE tax_calculations 
                    SET name = ?, start_date = ?, end_date = ?, percent_to_pay = ?
                    WHERE id = ?
                """, (name, start_date, end_date, percent, calc_id))
            else:
                creation_date = datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                cursor.execute("""
                    INSERT INTO tax_calculations (company_id, name, start_date, end_date, percent_to_pay, created_at)
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (company_id, name, start_date, end_date, percent, creation_date))
                calc_id = cursor.lastrowid
            cursor.execute("DELETE FROM tax_calculation_details WHERE calculation_id = ?", (calc_id,))
            details_to_insert = []
            for invoice_id, state in details.items():
                if state['selected']:
                    retention_applied = 1 if state['retention'] else 0
                    details_to_insert.append((calc_id, invoice_id, retention_applied))
            cursor.executemany("""
                INSERT INTO tax_calculation_details (calculation_id, invoice_id, itbis_retention_applied)
                VALUES (?, ?, ?)
            """, details_to_insert)
            self.conn.commit()
            return True, "Cálculo guardado exitosamente."
        except sqlite3.Error as e:
            self.conn.rollback()
            return False, f"Error al guardar el cálculo: {e}"

    def get_tax_calculations(self, company_id):
        """Obtiene la lista de cálculos guardados para una empresa."""
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT id, name, created_at FROM tax_calculations WHERE company_id = ? ORDER BY created_at DESC", (company_id,))
            return cursor.fetchall()
        except sqlite3.Error as e:
            print(f"Error al obtener cálculos: {e}")
            return []

    def get_tax_calculation_details(self, calculation_id):
        """Obtiene todos los detalles de un cálculo específico."""
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT * FROM tax_calculations WHERE id = ?", (calculation_id,))
            calc_data = cursor.fetchone()
            if not calc_data: return None
            cursor.execute("""
                SELECT invoice_id, itbis_retention_applied 
                FROM tax_calculation_details WHERE calculation_id = ?
            """, (calculation_id,))
            details = cursor.fetchall()
            return {"main": dict(calc_data), "details": {row['invoice_id']: bool(row['itbis_retention_applied']) for row in details}}
        except sqlite3.Error as e:
            print(f"Error al obtener detalles del cálculo: {e}")
            return None

    def delete_tax_calculation(self, calculation_id):
        """Elimina un cálculo y todos sus detalles."""
        try:
            cursor = self.conn.cursor()
            cursor.execute("DELETE FROM tax_calculations WHERE id = ?", (calculation_id,))
            self.conn.commit()
            return True, "Cálculo eliminado exitosamente."
        except sqlite3.Error as e:
            self.conn.rollback()
            return False, f"Error al eliminar el cálculo: {e}"

    def migrate_from_json(self, json_files):
        """
        Lee archivos JSON, inserta los datos de la empresa y sus facturas,
        y puebla el directorio de terceros (third_parties).
        """
        if not self.conn:
            return False, "Sin conexión a la base de datos."
        cursor = self.conn.cursor()
        for file_path in json_files:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                filename = os.path.basename(file_path)
                company_name_raw = filename.replace('facturas_', '').replace('.json', '')
                company_name = ' '.join(word.capitalize() for word in company_name_raw.split('_'))
                cursor.execute("SELECT id FROM companies WHERE name = ?", (company_name,))
                company_row = cursor.fetchone()
                if company_row is None:
                    print(f"Migrando nueva empresa: {company_name}")
                    itbis_adelantado = float(data.get('itbis_adelantado', 0.0))
                    cursor.execute("INSERT INTO companies (name, legacy_filename, itbis_adelantado) VALUES (?, ?, ?)",(company_name, filename, itbis_adelantado))
                    company_id = cursor.lastrowid
                    for factura in data.get("facturas_emitidas", []):
                        cursor.execute(
                            """INSERT INTO invoices (company_id, invoice_type, invoice_date, imputation_date, invoice_number, invoice_category, rnc, third_party_name, currency, itbis, total_amount, exchange_rate, total_amount_rd)
                            VALUES (?, 'emitida', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                            (company_id, factura.get('fecha'), factura.get('fecha_imputacion'), factura.get('no_fact'), factura.get('tipo_factura'), factura.get('rnc'), factura.get('empresa'), factura.get('moneda'), factura.get('itbis', 0.0), factura.get('factura_total', 0.0), factura.get('tasa_conversion', 1.0), factura.get('monto_convertido_rd', factura.get('factura_total', 0.0)))
                        )
                    for factura in data.get("facturas_gastos", []):
                        cursor.execute(
                            """INSERT INTO invoices (company_id, invoice_type, invoice_date, imputation_date, invoice_number, rnc, third_party_name, currency, itbis, total_amount, exchange_rate, total_amount_rd)
                            VALUES (?, 'gasto', ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                            (company_id, factura.get('fecha'), factura.get('fecha_imputacion'), factura.get('no_fact'), factura.get('rnc'), factura.get('lugar_compra'), factura.get('moneda'), factura.get('itbis', 0.0), factura.get('factura_total', 0.0), factura.get('tasa_conversion', 1.0), factura.get('monto_convertido_rd', factura.get('factura_total', 0.0)))
                        )
                    third_parties_to_add = set()
                    for f in data.get("facturas_emitidas", []):
                        if f.get('rnc') and f.get('empresa'):
                            third_parties_to_add.add((f['rnc'].strip(), f['empresa'].strip()))
                    for f in data.get("facturas_gastos", []):
                        if f.get('rnc') and f.get('lugar_compra'):
                            third_parties_to_add.add((f['rnc'].strip(), f['lugar_compra'].strip()))
                    for rnc, name in third_parties_to_add:
                        self.add_or_update_third_party(rnc, name)
                else:
                    print(f"La empresa {company_name} ya existe. Omitiendo migración para este archivo.")
            except Exception as e:
                self.conn.rollback()
                return False, f"Error migrando el archivo {file_path}: {e}"
        self.conn.commit()
        return True, "Migración completada exitosamente."

    def get_all_companies(self):
        """Recupera todas las empresas (id, name, rnc) de la base de datos."""
        if not self.conn: return []
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT id, name, rnc FROM companies ORDER BY name ASC")
            return cursor.fetchall()
        except sqlite3.Error as e:
            print(f"Error al obtener las empresas: {e}")
            return []

    def get_dashboard_data(self, company_id, filter_month=None, filter_year=None, specific_date=None):
        """
        Obtiene facturas y calcula totales para el dashboard, aplicando filtros opcionales.
        """
        if not self.conn or company_id is None:
            return None
        try:
            cursor = self.conn.cursor()
            query = "SELECT * FROM invoices WHERE company_id = ?"
            params = [company_id]
            if specific_date:
                query += " AND invoice_date = ?"
                params.append(specific_date.strftime('%Y-%m-%d'))
            elif filter_month and filter_year:
                query += " AND strftime('%Y', invoice_date) = ? AND strftime('%m', invoice_date) = ?"
                params.append(str(filter_year))
                params.append(str(filter_month).zfill(2))
            cursor.execute(query, params)
            all_invoices = cursor.fetchall()
            emitted = [dict(row) for row in all_invoices if row['invoice_type'] == 'emitida']
            expenses = [dict(row) for row in all_invoices if row['invoice_type'] == 'gasto']
            total_ingresos = sum(f['total_amount_rd'] for f in emitted)
            total_gastos = sum(f['total_amount_rd'] for f in expenses)
            itbis_ingresos = sum(f['itbis'] * f['exchange_rate'] for f in emitted)
            itbis_gastos = sum(f['itbis'] * f['exchange_rate'] for f in expenses)
            return {
                "all_transactions": sorted(all_invoices, key=lambda x: x['invoice_date'], reverse=True),
                "summary": {
                    "total_ingresos": total_ingresos, "total_gastos": total_gastos,
                    "itbis_ingresos": itbis_ingresos, "itbis_gastos": itbis_gastos,
                    "total_neto": total_ingresos - total_gastos,
                    "itbis_neto": itbis_ingresos - itbis_gastos
                }
            }
        except sqlite3.Error as e:
            print(f"Error al obtener datos del dashboard: {e}")
            return None

    def close_connection(self):
        """Cierra la conexión a la base de datos."""
        if self.conn:
            self.conn.close()
            print("Conexión a la base de datos cerrada.")

    def get_unique_invoice_years(self, company_id):
        """
        Recupera una lista de años únicos en los que una empresa tiene facturas.
        """
        if not self.conn or company_id is None:
            return []
        try:
            cursor = self.conn.cursor()
            query = "SELECT DISTINCT strftime('%Y', invoice_date) as year FROM invoices WHERE company_id = ? ORDER BY year DESC"
            cursor.execute(query, (company_id,))
            years = [row['year'] for row in cursor.fetchall()]
            return years
        except sqlite3.Error as e:
            print(f"Error al obtener años únicos: {e}")
            return []

    def get_itbis_adelantado(self, company_id):
        """Obtiene el ITBIS adelantado para una empresa específica."""
        if not self.conn or company_id is None:
            return 0.0
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT itbis_adelantado FROM companies WHERE id = ?", (company_id,))
            result = cursor.fetchone()
            return result['itbis_adelantado'] if result else 0.0
        except sqlite3.Error as e:
            print(f"Error al obtener ITBIS adelantado: {e}")
            return 0.0

    def update_itbis_adelantado(self, company_id, value):
        """Actualiza el ITBIS adelantado para una empresa específica."""
        if not self.conn or company_id is None:
            return False
        try:
            cursor = self.conn.cursor()
            cursor.execute("UPDATE companies SET itbis_adelantado = ? WHERE id = ?", (value, company_id))
            self.conn.commit()
            return True
        except sqlite3.Error as e:
            print(f"Error al actualizar ITBIS adelantado: {e}")
            return False

    def add_invoice(self, invoice_data: dict, items_data: list):
        """
        Inserta factura + items en una transacción.
        Retorna el id de la nueva factura.
        """
        print("[LogicController] add_invoice llamado")  # DEBUG 1
        print("[LogicController] invoice_data:", invoice_data)
        print("[LogicController] items_data:", items_data)

        cur = self.conn.cursor()
        try:
            self.conn.execute("BEGIN;")
            cur.execute("SELECT 1 FROM currencies WHERE name = ?", (invoice_data.get("currency"),))
            if cur.fetchone() is None:
                print(f"[LogicController] Moneda '{invoice_data.get('currency')}' no existe, insertando...")  # DEBUG 2
                cur.execute("INSERT OR IGNORE INTO currencies(name) VALUES(?)", (invoice_data.get("currency") or "RD$",))
            print("[LogicController] Ejecutando INSERT INTO invoices...")  # DEBUG 3
            cur.execute("""
                INSERT INTO invoices (
                    company_id, invoice_type, invoice_date, imputation_date,
                    invoice_number, invoice_category, rnc, third_party_name,
                    currency, itbis, total_amount, exchange_rate, total_amount_rd, attachment_path
                ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                invoice_data.get("company_id"),
                invoice_data.get("invoice_type"),
                invoice_data.get("invoice_date"),
                invoice_data.get("imputation_date"),
                invoice_data.get("invoice_number"),
                invoice_data.get("invoice_category"),
                invoice_data.get("rnc"),
                invoice_data.get("third_party_name"),
                invoice_data.get("currency"),
                float(invoice_data.get("itbis") or 0.0),
                float(invoice_data.get("total_amount") or 0.0),
                float(invoice_data.get("exchange_rate") or 1.0),
                float(invoice_data.get("total_amount_rd") or 0.0),
                invoice_data.get("attachment_path")
            ))
            invoice_id = cur.lastrowid
            print(f"[LogicController] ID de factura insertada: {invoice_id}")  # DEBUG 4
            if items_data:
                print(f"[LogicController] Insertando {len(items_data)} items...")  # DEBUG 5
                cur.executemany("""
                    INSERT INTO invoice_items (invoice_id, description, quantity, unit_price)
                    VALUES (?, ?, ?, ?)
                """, [
                    (invoice_id, (i.get("description") or "").strip(),
                    float(i.get("quantity") or 0.0), float(i.get("unit_price") or 0.0))
                    for i in items_data if (i.get("description") or "").strip()
                ])
            else:
                print("[LogicController] Sin items para insertar.")  # DEBUG 6
            self.conn.commit()
            print("[LogicController] Commit realizado correctamente.")  # DEBUG 7
            return invoice_id
        except IntegrityError as ie:
            self.conn.rollback()
            print(f"[LogicController] IntegrityError: {ie}")  # DEBUG 8
            raise
        except Exception as e:
            self.conn.rollback()
            print(f"[LogicController] Exception: {e}")  # DEBUG 9
            raise

    def update_invoice(self, invoice_id: int, invoice_data: dict, items_data: list):
        """
        Actualiza factura + reemplaza sus ítems en una transacción.
        Verifica duplicidad antes de actualizar.
        """
        cur = self.conn.cursor()
        try:
            company_id = invoice_data.get("company_id")
            rnc = invoice_data.get("rnc")
            invoice_number = invoice_data.get("invoice_number")
            cur.execute("""
                SELECT COUNT(*) FROM invoices
                WHERE company_id = ? AND rnc = ? AND invoice_number = ? AND id != ?
            """, (company_id, rnc, invoice_number, invoice_id))
            if cur.fetchone()[0] > 0:
                raise IntegrityError("Ya existe una factura con ese Número y RNC para la empresa.")
            self.conn.execute("BEGIN;")
            cur.execute("SELECT 1 FROM currencies WHERE name = ?", (invoice_data.get("currency"),))
            if cur.fetchone() is None:
                cur.execute("INSERT OR IGNORE INTO currencies(name) VALUES(?)", (invoice_data.get("currency") or "RD$",))
            cur.execute("""
                UPDATE invoices
                SET company_id = ?, invoice_type = ?, invoice_date = ?, imputation_date = ?,
                    invoice_number = ?, invoice_category = ?, rnc = ?, third_party_name = ?,
                    currency = ?, itbis = ?, total_amount = ?, exchange_rate = ?, total_amount_rd = ?, attachment_path = ?
                WHERE id = ?
            """, (
                invoice_data.get("company_id"),
                invoice_data.get("invoice_type"),
                invoice_data.get("invoice_date"),
                invoice_data.get("imputation_date"),
                invoice_data.get("invoice_number"),
                invoice_data.get("invoice_category"),
                invoice_data.get("rnc"),
                invoice_data.get("third_party_name"),
                invoice_data.get("currency"),
                float(invoice_data.get("itbis") or 0.0),
                float(invoice_data.get("total_amount") or 0.0),
                float(invoice_data.get("exchange_rate") or 1.0),
                float(invoice_data.get("total_amount_rd") or 0.0),
                invoice_data.get("attachment_path"),
                int(invoice_id)
            ))
            cur.execute("DELETE FROM invoice_items WHERE invoice_id = ?", (invoice_id,))
            if items_data:
                cur.executemany("""
                    INSERT INTO invoice_items (invoice_id, description, quantity, unit_price)
                    VALUES (?, ?, ?, ?)
                """, [
                    (invoice_id, (i.get("description") or "").strip(),
                    float(i.get("quantity") or 0.0), float(i.get("unit_price") or 0.0))
                    for i in items_data if (i.get("description") or "").strip()
                ])
            self.conn.commit()
        except IntegrityError as e:
            self.conn.rollback()
            raise
        except Exception:
            self.conn.rollback()
            raise

    def update_company(self, company_id, name, rnc, address, template_path, output_path):
        """
        Actualiza los datos de la empresa en la base de datos.
        """
        try:
            cursor = self.conn.cursor()
            cursor.execute("""
                UPDATE companies
                SET name = ?, rnc = ?, address = ?, invoice_template_path = ?, invoice_output_base_path = ?
                WHERE id = ?
            """, (name, rnc, address, template_path, output_path, company_id))
            self.conn.commit()
            return True, "Empresa actualizada correctamente."
        except Exception as e:
            return False, f"Error al actualizar la empresa: {e}"

    def get_currencies(self, company_id):
        """
        Devuelve la lista de monedas disponibles desde la base de datos.
        El parámetro company_id se mantiene por compatibilidad pero no se usa actualmente.
        """
        if not self.conn:
            return ["RD$", "USD"]
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT name FROM currencies ORDER BY name")
            return [row['name'] for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Error al obtener monedas: {e}")
            return ["RD$", "USD"]

    def search_third_parties(self, query, search_by='name'):
        """Busca en el directorio de terceros por nombre o RNC."""
        if not self.conn or len(query) < 2:
            return []
        try:
            cursor = self.conn.cursor()
            column = 'name' if search_by == 'name' else 'rnc'
            sql_query = f"SELECT rnc, name FROM third_parties WHERE {column} LIKE ? LIMIT 10"
            cursor.execute(sql_query, (f"{query}%",))
            return [dict(row) for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Error al buscar terceros: {e}")
            return []

    def add_or_update_third_party(self, rnc, name):
        """Añade un nuevo tercero o actualiza el nombre si el RNC ya existe."""
        if not self.conn or not rnc or not name:
            return
        try:
            cursor = self.conn.cursor()
            cursor.execute(
                """INSERT INTO third_parties (rnc, name) VALUES (?, ?)
                ON CONFLICT(rnc) DO UPDATE SET name=excluded.name""",
                (rnc.strip(), name.strip())
            )
            self.conn.commit()
        except sqlite3.Error as e:
            print(f"Error al añadir o actualizar tercero: {e}")

    def find_invoice_id_by_number(self, company_id: int, invoice_number: str):
        if not self.conn: return None
        cur = self.conn.cursor()
        cur.execute(
            "SELECT id FROM invoices WHERE company_id = ? AND invoice_number = ? ORDER BY id DESC LIMIT 1",
            (company_id, invoice_number),
        )
        row = cur.fetchone()
        return row[0] if row else None

    def get_invoice_by_id(self, invoice_id: int):
        if not self.conn: return None
        cur = self.conn.cursor()
        cur.execute("SELECT * FROM invoices WHERE id = ?", (invoice_id,))
        return cur.fetchone()

    def get_invoice_items(self, invoice_id):
        """Recupera todos los detalles de una factura por su ID."""
        if not self.conn or invoice_id is None:
            return []
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT description, quantity, unit_price FROM invoice_items WHERE invoice_id = ?", (invoice_id,))
            return [dict(row) for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Error al obtener detalles de la factura: {e}")
            return []

    def delete_invoice(self, invoice_id):
        """Elimina una factura de la base de datos por su ID."""
        if not self.conn:
            return False, "Sin conexión a la base de datos."
        try:
            cursor = self.conn.cursor()
            cursor.execute("DELETE FROM invoices WHERE id = ?", (invoice_id,))
            self.conn.commit()
            return True, "Factura eliminada exitosamente."
        except sqlite3.Error as e:
            self.conn.rollback()
            return False, f"Error de base de datos al eliminar: {e}"

    def get_monthly_report_data(self, company_id, month, year):
        """
        Obtiene los datos de facturas para un mes y año específicos para generar un reporte.
        """
        if not self.conn or company_id is None:
            return None
        report_data = self.get_dashboard_data(company_id, filter_month=month, filter_year=year)
        if not report_data:
            return None
        emitted_invoices = [dict(row) for row in report_data['all_transactions'] if row['invoice_type'] == 'emitida']
        expense_invoices = [dict(row) for row in report_data['all_transactions'] if row['invoice_type'] == 'gasto']
        return {
            "summary": report_data['summary'],
            "emitted_invoices": emitted_invoices,
            "expense_invoices": expense_invoices
        }

    def get_emitted_invoices_for_period(self, company_id, start_date, end_date):
        """Obtiene todas las facturas emitidas para una empresa dentro de un rango de fechas."""
        if not self.conn or not all([company_id, start_date, end_date]):
            return []
        try:
            cursor = self.conn.cursor()
            query = """
                SELECT * FROM invoices 
                WHERE company_id = ? 
                AND invoice_type = 'emitida'
                AND invoice_date BETWEEN ? AND ?
                ORDER BY invoice_date
            """
            cursor.execute(query, (company_id, start_date, end_date))
            return [dict(row) for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Error al obtener facturas emitidas por período: {e}")
            return []

    def get_setting(self, key, default=""):
        """Obtiene un valor de la tabla de configuración settings."""
        if not self.conn: return default
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT value FROM settings WHERE key = ?", (key,))
            row = cursor.fetchone()
            return row['value'] if row and row['value'] is not None else default
        except Exception:
            return default

    def set_setting(self, key, value):
        """Guarda un valor en la tabla de configuración."""
        try:
            cursor = self.conn.cursor()
            cursor.execute("INSERT OR REPLACE INTO settings (key, value) VALUES (?, ?)", (key, value))
            self.conn.commit()
        except sqlite3.Error as e:
            print(f"Error al guardar ajuste '{key}': {e}")

    def get_all_currencies(self):
        """Obtiene todas las monedas de la base de datos."""
        if not self.conn:
            return ["RD$", "USD"]
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT name FROM currencies ORDER BY name")
            return [row['name'] for row in cursor.fetchall()]
        except sqlite3.Error as e:
            print(f"Error al obtener monedas: {e}")
            return ["RD$", "USD"]

    def save_currencies(self, currency_list):
        """Borra y guarda la lista completa de monedas."""
        try:
            cursor = self.conn.cursor()
            cursor.execute("DELETE FROM currencies")
            cursor.executemany("INSERT INTO currencies (name) VALUES (?)", [(c,) for c in currency_list])
            self.conn.commit()
        except sqlite3.Error as e:
            print(f"Error al guardar monedas: {e}")

    def get_report_by_third_party(self, company_id, third_party_rnc):
        """Obtiene todas las facturas y totales para un cliente/proveedor específico."""
        if not all([self.conn, company_id, third_party_rnc]):
            return None
        try:
            cursor = self.conn.cursor()
            query = "SELECT * FROM invoices WHERE company_id = ? AND rnc = ? ORDER BY invoice_date DESC"
            cursor.execute(query, (company_id, third_party_rnc))
            all_invoices = [dict(row) for row in cursor.fetchall()]
            emitted = [f for f in all_invoices if f['invoice_type'] == 'emitida']
            expenses = [f for f in all_invoices if f['invoice_type'] == 'gasto']
            total_ingresos = sum(f['total_amount_rd'] for f in emitted)
            total_gastos = sum(f['total_amount_rd'] for f in expenses)
            return {
                "summary": {
                    "total_ingresos": total_ingresos,
                    "total_gastos": total_gastos
                },
                "emitted_invoices": emitted,
                "expense_invoices": expenses
            }
        except sqlite3.Error as e:
            print(f"Error al obtener reporte por tercero: {e}")
            return None

    def reconnect(self):
        """Cierra y reabre la conexión a la base de datos."""
        self.close_connection()
        self._connect()

    def add_company(self, name, rnc):
        """Añade una nueva empresa con su RNC a la base de datos."""
        if not self.conn or not name or not rnc:
            return False, "Nombre y RNC son requeridos."
        try:
            cursor = self.conn.cursor()
            cursor.execute("INSERT INTO companies (name, rnc) VALUES (?, ?)", (name, rnc))
            self.conn.commit()
            return True, "Empresa añadida exitosamente."
        except sqlite3.IntegrityError:
            self.conn.rollback()
            return False, "Ya existe una empresa con ese nombre o RNC."
        except sqlite3.Error as e:
            self.conn.rollback()
            return False, f"Error de base de datos: {e}"

    def get_company_details(self, company_id):
        """Recupera todos los detalles de una única empresa por su ID."""
        if not self.conn or not company_id:
            return None
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT * FROM companies WHERE id = ?", (company_id,))
            result = cursor.fetchone()
            return dict(result) if result else None
        except sqlite3.Error as e:
            print(f"Error al obtener detalles de la empresa: {e}")
            return None

    def delete_company(self, company_id):
        """Elimina una empresa y todas sus facturas asociadas."""
        if not self.conn or not company_id:
            return False, "ID de empresa inválido o sin conexión."
        try:
            cursor = self.conn.cursor()
            cursor.execute("DELETE FROM invoices WHERE company_id = ?", (company_id,))
            cursor.execute("DELETE FROM companies WHERE id = ?", (company_id,))
            self.conn.commit()
            return True, "Empresa y todos sus datos eliminados exitosamente."
        except sqlite3.Error as e:
            self.conn.rollback()
            return False, f"Error de base de datos: {e}"


    def get_next_ncf(self, company_id, prefix):
        """
        Devuelve el próximo NCF para una empresa y prefijo, con exactamente 8 dígitos.
        Ejemplo: 'B0100000015'
        """
        try:
            cursor = self.conn.cursor()
            query = """
                SELECT invoice_number FROM invoices 
                WHERE company_id = ? AND invoice_type = 'emitida' AND invoice_number LIKE ? 
                AND LENGTH(invoice_number) = ?
                ORDER BY invoice_number DESC LIMIT 1
            """
            total_length = len(prefix) + 8
            cursor.execute(query, (company_id, f"{prefix}%", total_length))
            last_ncf = cursor.fetchone()
            if not last_ncf:
                return f"{prefix}00000001"
            ncf_str = last_ncf['invoice_number']
            numeric_part = ncf_str[len(prefix):]
            if not numeric_part.isdigit() or len(numeric_part) != 8:
                return f"{prefix}00000001"
            next_number = int(numeric_part) + 1
            return f"{prefix}{next_number:08d}"
        except sqlite3.Error as e:
            print(f"Error al obtener el siguiente NCF: {e}")
            return f"{prefix}00000001"

    def _as_dict(self, obj, columns=None):
        """Normaliza obj a dict. Acepta dict, sqlite3.Row, tuple/list (con columns), str/otros."""
        if obj is None:
            return {}
        if isinstance(obj, dict):
            return obj
        try:
            import sqlite3
            if isinstance(obj, sqlite3.Row):
                return dict(obj)
        except Exception:
            pass
        if isinstance(obj, (list, tuple)) and columns and len(columns) == len(obj):
            return {k: v for k, v in zip(columns, obj)}
        if hasattr(obj, "get"):
            try:
                return dict(obj)
            except Exception:
                pass
        return {"_raw": obj}

    def _row_to_dict(self, row, cursor):
        """Convierte un row de sqlite a dict usando cursor.description."""
        if row is None:
            return None
        if isinstance(row, dict):
            return row
        try:
            import sqlite3
            if isinstance(row, sqlite3.Row):
                return dict(row)
        except Exception:
            pass
        if isinstance(row, (list, tuple)) and cursor and cursor.description:
            cols = [d[0] for d in cursor.description]
            return {k: v for k, v in zip(cols, row)}
        return {"_raw": row}

    def get_active_company_id_from_settings(self):
        """
        Intenta resolver la empresa activa desde la tabla settings.
        Claves soportadas: active_company_id, current_company_id, selected_company_id, active_company_name.
        """
        for k in ("active_company_id", "current_company_id", "selected_company_id"):
            val = self.get_setting(k)
            if val:
                try:
                    v = int(val)
                    if v > 0:
                        return v
                except Exception:
                    pass
        name = self.get_setting("active_company_name") or self.get_setting("current_company_name")
        if name:
            row = self.get_company_by_name(str(name).strip())
            if row:
                try:
                    return int(row["id"])
                except Exception:
                    try:
                        return int(row[0])
                    except Exception:
                        pass
        return None

    def find_invoice_id_by_number_any(self, invoice_number: str):
        """
        Fallback cuando no tenemos company_id: busca por NCF sin filtrar empresa.
        OJO: si tienes el mismo NCF en varias empresas, devolverá el más reciente.
        """
        if not self.conn: return None, None
        cur = self.conn.cursor()
        cur.execute(
            "SELECT id, company_id FROM invoices WHERE invoice_number = ? ORDER BY id DESC LIMIT 1",
            (invoice_number,),
        )
        row = cur.fetchone()
        if not row:
            return None, None
        try:
            rid = int(row["id"]); cid = int(row["company_id"])
        except Exception:
            rid, cid = int(row[0]), int(row[1])
        return rid, cid
    

    def safe_makedirs(self, full_path):
        """
        Crea carpetas solo si la unidad/base existe. Si no, lanza un FileNotFoundError.
        """
        drive, _ = os.path.splitdrive(full_path)
        if drive and not os.path.exists(drive):
            raise FileNotFoundError(f"La unidad {drive} no existe o no está conectada.\nVerifica la ruta en configuración.")
        os.makedirs(full_path, exist_ok=True)

    def ensure_attachment_folder_exists(self, company_name, for_date):
        """
        Asegura que la estructura de carpetas para una empresa y fecha exista.
        Devuelve la ruta completa de la carpeta del mes, preguntando al usuario si la base no existe.
        """
        base_path = self.get_attachment_base_path()
        if not base_path or not os.path.isdir(base_path):
            return None
        sanitized_company_name = "".join(c for c in company_name if c not in '<>:"/\\|?*')
        year_str = str(for_date.year)
        month_str = f"{for_date.month:02d}"
        full_path = os.path.join(base_path, sanitized_company_name, year_str, month_str)
        try:
            self.safe_makedirs(full_path)
        except FileNotFoundError as e:
            # Aquí podrías mostrar un diálogo y pedir al usuario una nueva carpeta base
            import tkinter as tk
            from tkinter import filedialog, messagebox
            root_temp = tk.Tk(); root_temp.withdraw()
            messagebox.showerror("Error de Ruta", str(e))
            selected_path = filedialog.askdirectory(title="Selecciona la nueva carpeta raíz de anexos (Dropbox u otra)")
            root_temp.destroy()
            if selected_path and os.path.isdir(selected_path):
                # Actualiza config y empresa activa
                config = config_manager.load_config()
                config['carpeta_destino'] = selected_path
                config_manager.save_config(config)
                company_id = self.get_active_company_id_from_settings()
                empresa_cfg = config_manager.get_empresa_config(company_id)
                if empresa_cfg is not None:
                    empresa_cfg['carpeta_destino'] = selected_path
                    config_manager.set_empresa_config(company_id, empresa_cfg)
                base_path = selected_path
                full_path = os.path.join(base_path, sanitized_company_name, year_str, month_str)
                self.safe_makedirs(full_path)
                return full_path
            else:
                return None
        return full_path

    def get_attachment_base_path(self):
        """
        Devuelve la ruta absoluta de la carpeta base de anexos, usando la configuración de la empresa activa.
        Si no está configurada o no existe, pregunta al usuario y la guarda en config.
        """
        company_id = self.get_active_company_id_from_settings()
        empresa_cfg = config_manager.get_empresa_config(company_id)
        base_path = None
        if empresa_cfg and empresa_cfg.get('carpeta_destino'):
            base_path = empresa_cfg.get('carpeta_destino')
        else:
            config = config_manager.load_config()
            base_path = config.get('carpeta_destino') or config.get('attachment_base_path')

        while True:
            if not base_path or not os.path.isdir(base_path):
                root_temp = tk.Tk(); root_temp.withdraw()
                messagebox.showinfo(
                    "Seleccionar Carpeta de Anexos",
                    "No se ha configurado la carpeta raíz de anexos.\nPor favor, selecciona la carpeta donde se guardarán los comprobantes."
                )
                selected_path = filedialog.askdirectory(
                    title="Selecciona la carpeta raíz de anexos (Dropbox u otra)"
                )
                root_temp.destroy()
                if selected_path and os.path.isdir(selected_path):
                    config = config_manager.load_config()
                    config['carpeta_destino'] = selected_path
                    config['attachment_base_path'] = selected_path
                    config_manager.save_config(config)
                    if empresa_cfg is not None:
                        empresa_cfg['carpeta_destino'] = selected_path
                        config_manager.set_empresa_config(company_id, empresa_cfg)
                    empresa_cfg = config_manager.get_empresa_config(company_id)
                    base_path = empresa_cfg.get('carpeta_destino') if empresa_cfg else selected_path
                else:
                    messagebox.showerror(
                        "Error de Configuración",
                        "No se seleccionó ninguna carpeta válida. No se puede continuar."
                    )
                    return None
            else:
                break
        return base_path
    
    def get_invoice_output_path(self, company_id, ncf_type):
        """
        Construye la ruta de salida dinámica para una factura.
        Si la unidad no existe, pregunta al usuario por una nueva carpeta base y la guarda correctamente.
        Ej: Dropbox/Mis Facturas/Facturas B01/2025/09/
        """
        details = self.get_company_details(company_id)
        base_path = details.get('invoice_output_base_path') if details else None

        today = datetime.date.today()
        year = str(today.year)
        month = f"{today.month:02d}"

        # Armamos full_path con la ruta actual
        if base_path:
            full_path = os.path.join(base_path, f"Facturas {ncf_type}", year, month)
        else:
            full_path = None

        while True:
            try:
                if not base_path or not os.path.isdir(base_path):
                    root_temp = tk.Tk(); root_temp.withdraw()
                    messagebox.showinfo("Ruta de Facturas no configurada",
                        "No se ha configurado la carpeta base para guardar facturas.\nPor favor, selecciona una carpeta.")
                    selected_path = filedialog.askdirectory(title="Selecciona la carpeta base para guardar facturas")
                    root_temp.destroy()
                    if selected_path and os.path.isdir(selected_path):
                        config = config_manager.load_config()
                        config['invoice_output_base_path'] = selected_path
                        config_manager.save_config(config)
                        if details and details.get("rnc"):
                            empresa_cfg = config_manager.get_empresa_config(details["rnc"])
                            if empresa_cfg is not None:
                                empresa_cfg['carpeta_salida'] = selected_path
                                config_manager.set_empresa_config(details["rnc"], empresa_cfg)
                        base_path = selected_path
                        full_path = os.path.join(base_path, f"Facturas {ncf_type}", year, month)
                    else:
                        return None
                self.safe_makedirs(full_path)
                break
            except FileNotFoundError as e:
                root_temp = tk.Tk(); root_temp.withdraw()
                messagebox.showerror("Error de Ruta", str(e))
                selected_path = filedialog.askdirectory(title="Selecciona la nueva carpeta base para guardar facturas")
                root_temp.destroy()
                if selected_path and os.path.isdir(selected_path):
                    config = config_manager.load_config()
                    config['invoice_output_base_path'] = selected_path
                    config_manager.save_config(config)
                    if details and details.get("rnc"):
                        empresa_cfg = config_manager.get_empresa_config(details["rnc"])
                        if empresa_cfg is not None:
                            empresa_cfg['carpeta_salida'] = selected_path
                            config_manager.set_empresa_config(details["rnc"], empresa_cfg)
                    base_path = selected_path
                    full_path = os.path.join(base_path, f"Facturas {ncf_type}", year, month)
                else:
                    return None

        return full_path
    
    def get_downloads_folder_path(self):
        """
        Devuelve la ruta de la carpeta de descargas, usando la configuración de la empresa activa.
        Si no existe, pregunta al usuario y la guarda en config y empresa activa.
        """
        company_id = self.get_active_company_id_from_settings()
        empresa_cfg = config_manager.get_empresa_config(company_id)
        downloads_path = None
        if empresa_cfg and empresa_cfg.get('carpeta_origen'):
            downloads_path = empresa_cfg.get('carpeta_origen')
        else:
            config = config_manager.load_config()
            downloads_path = config.get('downloads_folder_path')

        while True:
            if not downloads_path or not os.path.isdir(downloads_path):
                root_temp = tk.Tk(); root_temp.withdraw()
                messagebox.showinfo(
                    "Seleccionar Carpeta de Descargas",
                    "No se ha configurado la carpeta de descargas.\nPor favor, selecciona la carpeta donde se descargarán los comprobantes."
                )
                selected_path = filedialog.askdirectory(
                    title="Selecciona la carpeta de Descargas"
                )
                root_temp.destroy()
                if selected_path and os.path.isdir(selected_path):
                    config = config_manager.load_config()
                    config['downloads_folder_path'] = selected_path
                    config_manager.save_config(config)
                    if empresa_cfg is not None:
                        empresa_cfg['carpeta_origen'] = selected_path
                        config_manager.set_empresa_config(company_id, empresa_cfg)
                    empresa_cfg = config_manager.get_empresa_config(company_id)
                    downloads_path = empresa_cfg.get('carpeta_origen') if empresa_cfg else selected_path
                else:
                    messagebox.showerror(
                        "Error de Configuración",
                        "No se seleccionó ninguna carpeta válida. No se puede continuar."
                    )
                    return None
            else:
                break
        return downloads_path
    
    def get_invoice_template_path(self, company_id):
        """
        Devuelve la ruta de la plantilla de factura, preguntando al usuario y guardando si no existe.
        """
        details = self.get_company_details(company_id)
        template_path = details.get('invoice_template_path') if details else None

        while True:
            if not template_path or not os.path.isfile(template_path):
                root_temp = tk.Tk(); root_temp.withdraw()
                messagebox.showinfo(
                    "Seleccionar Plantilla de Factura",
                    "No se ha configurado la plantilla de factura.\nPor favor, selecciona el archivo de plantilla."
                )
                selected_path = filedialog.askopenfilename(
                    title="Selecciona la plantilla de factura",
                    filetypes=[("Archivos de Excel", "*.xlsx"), ("Todos los archivos", "*.*")]
                )
                root_temp.destroy()
                if selected_path and os.path.isfile(selected_path):
                    config = config_manager.load_config()
                    config['invoice_template_path'] = selected_path
                    config_manager.save_config(config)
                    if details and details.get("rnc"):
                        empresa_cfg = config_manager.get_empresa_config(details["rnc"])
                        if empresa_cfg is not None:
                            empresa_cfg['ruta_plantilla'] = selected_path
                            config_manager.set_empresa_config(details["rnc"], empresa_cfg)
                    details = self.get_company_details(company_id)
                    template_path = details.get('invoice_template_path')
                else:
                    messagebox.showerror(
                        "Error de Configuración",
                        "No se seleccionó ninguna plantilla válida. No se puede continuar."
                    )
                    return None
            else:
                break
        return template_path

### Archivo: settings_window.py

import tkinter as tk
from tkinter import ttk, messagebox, simpledialog, filedialog
import os
import config_manager

def get_company_rnc_by_name(company_name):
    """
    Busca el RNC de una empresa usando el nombre en el config.
    Retorna el RNC si lo encuentra, None si no.
    """
    config = config_manager.load_config()
    for rnc, empresa in config.get("empresas", {}).items():
        if empresa.get("nombre") == company_name:
            return rnc
    return None


def get_rnc_by_name(company_name):
    config = config_manager.load_config()
    for rnc, empresa in config.get("empresas", {}).items():
        if empresa.get("nombre") == company_name:
            return rnc
    return None

class SettingsWindow(tk.Toplevel):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.parent = parent
        self.controller = controller

        self.title("Configuración")
        self.geometry("600x650")
        self.resizable(False, False)
        self.grab_set()

        self.company_vars = {
            'company_name': tk.StringVar(),
            'company_rnc': tk.StringVar(),
            'company_address': tk.StringVar(),
            'invoice_template_path': tk.StringVar(),
            'invoice_output_base_path': tk.StringVar()
        }
        self._build_ui()
        self._load_settings()

    def _build_ui(self):
        main_frame = ttk.Frame(self, padding=10)
        main_frame.pack(fill=tk.BOTH, expand=True)

        company_frame = ttk.LabelFrame(main_frame, text="Datos de la Empresa Activa", padding=10)
        company_frame.pack(fill=tk.X, pady=(0, 10))
        ttk.Label(company_frame, text="Nombre:").grid(row=0, column=0, sticky="w", padx=5, pady=3)
        ttk.Entry(company_frame, textvariable=self.company_vars['company_name'], width=50).grid(row=0, column=1, sticky="ew", padx=5, pady=3)
        ttk.Label(company_frame, text="RNC:").grid(row=1, column=0, sticky="w", padx=5, pady=3)
        ttk.Entry(company_frame, textvariable=self.company_vars['company_rnc'], width=50).grid(row=1, column=1, sticky="ew", padx=5, pady=3)
        ttk.Label(company_frame, text="Dirección:").grid(row=2, column=0, sticky="w", padx=5, pady=3)
        ttk.Entry(company_frame, textvariable=self.company_vars['company_address'], width=50).grid(row=2, column=1, sticky="ew", padx=5, pady=3)
        company_frame.columnconfigure(1, weight=1)

        ttk.Label(company_frame, text="Ruta de Plantilla:").grid(row=3, column=0, sticky="w", padx=5, pady=3)
        ttk.Entry(company_frame, textvariable=self.company_vars['invoice_template_path'], width=50).grid(row=3, column=1, sticky="ew", padx=5, pady=3)
        ttk.Button(company_frame, text="Seleccionar...", command=self._browse_template).grid(row=3, column=2, padx=5)

        ttk.Label(company_frame, text="Carpeta Base de Salida:").grid(row=4, column=0, sticky="w", padx=5, pady=3)
        ttk.Entry(company_frame, textvariable=self.company_vars['invoice_output_base_path'], width=50).grid(row=4, column=1, sticky="ew", padx=5, pady=3)
        ttk.Button(company_frame, text="Seleccionar...", command=self._browse_output_folder).grid(row=4, column=2, padx=5)

        downloads_frame = ttk.LabelFrame(main_frame, text="Carpeta de Origen (ej: Descargas de WhatsApp)", padding=10)
        downloads_frame.pack(fill=tk.X, pady=(0, 10))
        self.downloads_path_var = tk.StringVar()
        downloads_entry = ttk.Entry(downloads_frame, textvariable=self.downloads_path_var, state="readonly")
        downloads_entry.grid(row=0, column=0, sticky="ew", padx=5)
        downloads_btn = ttk.Button(downloads_frame, text="Seleccionar...", command=self._browse_downloads_folder)
        downloads_btn.grid(row=0, column=1, padx=(5, 0))
        downloads_frame.columnconfigure(0, weight=1)

        path_frame = ttk.LabelFrame(main_frame, text="Carpeta de Destino (ej: Carpeta en Dropbox)", padding=10)
        path_frame.pack(fill=tk.X, pady=(0, 10))
        self.attachment_path_var = tk.StringVar()
        path_entry = ttk.Entry(path_frame, textvariable=self.attachment_path_var, state="readonly")
        path_entry.grid(row=0, column=0, sticky="ew", padx=5)
        browse_btn = ttk.Button(path_frame, text="Seleccionar...", command=self._browse_folder)
        browse_btn.grid(row=0, column=1, padx=(5, 0))
        path_frame.columnconfigure(0, weight=1)

        curr_frame = ttk.LabelFrame(main_frame, text="Gestión de Monedas", padding=10)
        curr_frame.pack(fill=tk.BOTH, expand=True)
        self.currency_listbox = tk.Listbox(curr_frame)
        self.currency_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True, padx=(0, 10))
        curr_buttons_frame = ttk.Frame(curr_frame)
        curr_buttons_frame.pack(side=tk.LEFT, fill=tk.Y)
        ttk.Button(curr_buttons_frame, text="Añadir...", command=self._add_currency).pack(pady=2, fill=tk.X)
        ttk.Button(curr_buttons_frame, text="Eliminar", command=self._delete_currency).pack(pady=2, fill=tk.X)

        action_frame = ttk.Frame(main_frame)
        action_frame.pack(fill=tk.X, pady=(15, 0))
        ttk.Button(action_frame, text="Cancelar", command=self.destroy).pack(side=tk.RIGHT, padx=5)
        ttk.Button(action_frame, text="Guardar Cambios", command=self._save_settings, style="Accent.TButton").pack(side=tk.RIGHT)

    def _browse_template(self):
        path = filedialog.askopenfilename(title="Seleccionar Plantilla de Factura", filetypes=[("Archivos de Excel", "*.xlsx")])
        if path:
            self.company_vars['invoice_template_path'].set(path)

    def _browse_output_folder(self):
        path = filedialog.askdirectory(title="Seleccionar Carpeta Base para Guardar Facturas")
        if path:
            self.company_vars['invoice_output_base_path'].set(path)

    def _browse_downloads_folder(self):
        path = filedialog.askdirectory(title="Selecciona tu carpeta de Descargas")
        if path:
            self.downloads_path_var.set(path)

    def _browse_folder(self):
        path = filedialog.askdirectory(title="Selecciona la carpeta raíz para guardar los comprobantes")
        if path:
            self.attachment_path_var.set(path)

    def _load_settings(self):
        company_name = self.parent.get_current_company_name()  # Obtén el nombre desde el dashboard
        company_id = get_rnc_by_name(company_name)  # Busca el RNC real en el JSON
        empresa_cfg = config_manager.get_empresa_config(company_id) if company_id else {}

        self.company_vars['company_rnc'].set(company_id or "")
        self.company_vars['company_name'].set(company_name or "")
        self.company_vars['company_address'].set(empresa_cfg.get('direccion', ''))
        self.company_vars['invoice_template_path'].set(empresa_cfg.get('ruta_plantilla', ''))
        self.company_vars['invoice_output_base_path'].set(empresa_cfg.get('carpeta_salida', ''))
        self.downloads_path_var.set(empresa_cfg.get('carpeta_origen', ''))
        self.attachment_path_var.set(empresa_cfg.get('carpeta_destino', ''))
        self.currency_listbox.delete(0, tk.END)
        for moneda in empresa_cfg.get('monedas', []):
            self.currency_listbox.insert(tk.END, moneda)


    def _save_settings(self):
        try:
            company_name = self.company_vars['company_name'].get()
            # Buscar el RNC usando el nombre actual del formulario (por si se edita)
            company_id = self.company_vars['company_rnc'].get() or get_rnc_by_name(company_name)
            if not company_id:
                raise Exception("No se pudo determinar el RNC de la empresa.")

            empresa_cfg = {
                'nombre': company_name,
                'direccion': self.company_vars['company_address'].get(),
                'ruta_plantilla': self.company_vars['invoice_template_path'].get(),
                'carpeta_salida': self.company_vars['invoice_output_base_path'].get(),
                'carpeta_origen': self.downloads_path_var.get(),
                'carpeta_destino': self.attachment_path_var.get(),
                'monedas': list(self.currency_listbox.get(0, tk.END))
            }

            # Actualiza la configuración en el JSON
            config_manager.set_empresa_config(company_id, empresa_cfg)
            config_manager.set_empresa_activa(company_id)  # Marca como activa

            # Si tienes lógica SQL para actualizar en la base de datos, llama aquí:
            if hasattr(self.controller, 'update_company'):
                self.controller.update_company(
                    company_id,
                    empresa_cfg['nombre'],
                    company_id,
                    empresa_cfg['direccion'],
                    empresa_cfg['ruta_plantilla'],
                    empresa_cfg['carpeta_salida']
                )
                if hasattr(self.parent, '_populate_company_selector'):
                    self.parent._populate_company_selector()

            # Si manejas monedas en la base de datos
            if hasattr(self.controller, 'save_currencies'):
                self.controller.save_currencies(empresa_cfg['monedas'])

            messagebox.showinfo("Éxito", "Configuración guardada correctamente.", parent=self)
            self.destroy()
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo guardar la configuración: {e}", parent=self)

    def _add_currency(self):
        new_currency = simpledialog.askstring("Añadir Moneda", "Introduce el símbolo (ej. EUR):", parent=self)
        if new_currency and new_currency.strip() and new_currency.upper() not in self.currency_listbox.get(0, tk.END):
            self.currency_listbox.insert(tk.END, new_currency.upper())

    def _delete_currency(self):
        selected_indices = self.currency_listbox.curselection()
        if not selected_indices: return
        for i in reversed(selected_indices):
            self.currency_listbox.delete(i)

### Archivo: config_manager.py

import json
import os

CONFIG_FILE = "facturas_config.json"

def load_config():
    """Carga el archivo de configuración completo."""
    if os.path.exists(CONFIG_FILE):
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                return {}
    return {}

def set_db_path(db_path):
    config = load_config()
    config["database_path"] = db_path
    save_config(config)

def save_config(data):
    """Guarda el diccionario completo en el archivo."""
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=2, ensure_ascii=False)

def get_empresa_config(company_id):
    """Devuelve la configuración de una empresa específica por su id (RNC, nombre, o id único)."""
    config = load_config()
    empresas = config.get("empresas", {})
    return empresas.get(company_id, {})

def set_empresa_config(company_id, empresa_cfg):
    """Guarda la configuración específica de una empresa."""
    config = load_config()
    if "empresas" not in config:
        config["empresas"] = {}
    config["empresas"][company_id] = empresa_cfg
    save_config(config)

def set_empresa_activa(company_id):
    """Actualiza el campo de empresa activa."""
    config = load_config()
    config["empresa_activa"] = company_id
    save_config(config)

def get_empresa_activa():
    """Devuelve el id de la empresa activa"""
    config = load_config()
    return config.get("empresa_activa")

### Archivo: add_invoice_window.py


# Archivo: add_invoice_window.py (Actualizado con Visor)

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from tkcalendar import DateEntry
import datetime
import os
import shutil
from mini_calculator_window import MiniCalculator
from attachment_editor_window import AttachmentEditorWindow  # Importamos la nueva ventana
from PIL import Image, ImageTk
import re
import config_manager  # Asegúrate que está importado

class AddInvoiceWindow(tk.Toplevel):
    def __init__(self, parent, controller, save_callback, invoice_type, existing_data=None):
        super().__init__(parent.root)
        self.parent = parent
        self.controller = controller
        self.save_callback = save_callback
        self.invoice_type = invoice_type
        self.existing_data = existing_data
        self.attachment_relative_path = tk.StringVar()
        self.entries = {}

        try:
            img = Image.open("calculator_icon.png").resize((16, 16))
            self.calc_icon = ImageTk.PhotoImage(img)
        except Exception:
            self.calc_icon = None

        mode = "Modificar" if existing_data else "Registrar"
        title_text = "Gasto" if invoice_type == 'gasto' else "Ingreso"
        self.title(f"{mode} {title_text}")
        self.geometry("650x600")
        self.grab_set()

        frame_text = f"Datos de Factura de {title_text}"
        third_party_label = "Lugar de Compra/Empresa:" if invoice_type == 'gasto' else "Empresa a la que se emitió:"
        self._build_form(frame_text, third_party_label)
        if self.existing_data:
            self._populate_form()

    def _populate_form(self):
        data = self.existing_data
        if not data:
            return
        try:
            year, month, day = map(int, data['invoice_date'].split('-'))
            self.entries['fecha'].set_date(datetime.date(year, month, day))
        except Exception:
            pass
        self.entries['número_de_factura'].delete(0, tk.END)
        self.entries['número_de_factura'].insert(0, data.get('invoice_number', ''))
        self.entries['rnc_cédula'].delete(0, tk.END)
        self.entries['rnc_cédula'].insert(0, data.get('rnc', ''))
        self.entries['itbis'].delete(0, tk.END)
        self.entries['itbis'].insert(0, data.get('itbis', ''))
        self.entries['factura_total'].delete(0, tk.END)
        self.entries['factura_total'].insert(0, data.get('total_amount', ''))
        self.entries['moneda'].set(data.get('currency', 'RD$'))
        if self.invoice_type == 'emitida':
            self.entries['tipo_de_factura'].set(data.get('invoice_category', ''))
            self.entries['empresa_a_la_que_se_emitió'].delete(0, tk.END)
            self.entries['empresa_a_la_que_se_emitió'].insert(0, data.get('third_party_name', ''))
        else:
            self.entries['lugar_de_compra_empresa'].delete(0, tk.END)
            self.entries['lugar_de_compra_empresa'].insert(0, data.get('third_party_name', ''))
            if data.get('attachment_path'):
                self.attachment_relative_path.set(data['attachment_path'])
            else:
                self.attachment_relative_path.set("")

    # ====== HELPERS TOLERANTES PARA LEER EL FORM ======


    def _debug_dump_widgets(self, tag=""):
        print("\n[DEBUG] ===== DUMP WIDGETS", tag, "=====")
        for name in dir(self):
            if name.startswith("_"):  # ignora internos
                continue
            try:
                obj = getattr(self, name)
            except Exception:
                continue
            # Solo objetos con .get() (Entry, Combobox, StringVar, etc.)
            if hasattr(obj, "get") and callable(getattr(obj, "get")):
                try:
                    val = obj.get()
                    sval = "" if val is None else str(val)
                    print(f"[DEBUG] {name:<35} -> {sval!r}")
                except Exception as e:
                    print(f"[DEBUG] {name:<35} -> <error {e}>")
        print("[DEBUG] ===== FIN DUMP =====\n")


    def _val_from_widget(self, *attr_names, default=""):
        """
        Devuelve el valor .get() del primer atributo existente entre attr_names.
        Soporta Entry, Combobox, DateEntry, StringVar/DoubleVar/IntVar.
        Si no encuentra nada, devuelve default.
        """
        import datetime
        for name in attr_names:
            if hasattr(self, name):
                w = getattr(self, name)
                # Variables de Tk
                for var_type in ("get",):
                    if hasattr(w, var_type) and callable(getattr(w, var_type)):
                        try:
                            v = w.get()
                            # DateEntry (tkcalendar) a 'YYYY-MM-DD'
                            if hasattr(w, "get_date"):
                                try:
                                    d = w.get_date()
                                    if isinstance(d, (datetime.date, datetime.datetime)):
                                        return d.strftime("%Y-%m-%d")
                                except Exception:
                                    pass
                            # Normalizar a str
                            return ("" if v is None else str(v)).strip()
                        except Exception:
                            pass
        return default

    def _parse_decimal(self, val):
        """Igual que el helper del callback, pero local por si no está importado aquí."""
        if val is None:
            return "0"
        if isinstance(val, (int, float)):
            return str(float(val))
        s = str(val).strip()
        if not s:
            return "0"
        s = s.replace(" ", "")
        if s.count(",") == 1 and s.count(".") > 1:
            s = s.replace(".", "")
            s = s.replace(",", ".")
        elif s.count(",") == 1 and s.count(".") == 0:
            s = s.replace(",", ".")
        try:
            return str(float(s))
        except Exception:
            return "0"

    def _collect_form_data(self):
        # DUMPS de apoyo
        self._debug_dump_entries()
        self._debug_dump_widgets(tag="ANTES_DE_GUARDAR")

        # 1) Número de factura: primero intenta en self.entries por etiquetas típicas
        numero = self._get_from_entries([
            "número de factura", "numero de factura", "número", "numero",
            "ncf", "no.", "no", "invoice number"
        ])
        if not numero:
            numero = self._guess_invoice_number()
        print(f"[DEBUG] numero (entries/guess) -> {numero!r}")

        # 2) RNC/Cédula
        rnc = self._get_from_entries(["rnc", "rnc/cédula", "rnc/cedula", "cedula", "cédula"]) \
            or self._val_from_widget("entry_rnc", "ent_rnc", "txt_rnc", "var_rnc", "entry_rnc_cedula", "txt_rnc_cedula")
        print(f"[DEBUG] rnc -> {rnc!r}")

        # 3) Tercero (empresa/lugar)
        tercero = self._get_from_entries([
            "empresa a la que se emitió", "empresa a la que se emitio",
            "empresa", "lugar", "lugar de compra", "lugar de compra/empresa"
        ]) or self._val_from_widget(
            "entry_third_party", "ent_third_party", "txt_third_party",
            "entry_empresa", "entry_lugar_compra", "txt_empresa"
        )
        print(f"[DEBUG] tercero -> {tercero!r}")

        # 4) Fechas
        fecha_factura = self._get_from_entries(["fecha", "fecha factura", "fecha de factura"]) \
                        or self._val_from_widget("date_invoice", "dt_invoice", "de_invoice", "entry_fecha_factura")
        fecha_imput = self._get_from_entries(["fecha imputación", "fecha imputacion"]) \
                    or self._val_from_widget("date_imputation", "dt_imputation", "de_imputation", "entry_fecha_imputacion")
        print(f"[DEBUG] fechas -> factura={fecha_factura!r} imputación={fecha_imput!r}")

        # 5) Moneda
        moneda = self._get_from_entries(["moneda", "currency"]) \
                or self._val_from_widget("combo_currency", "cmb_currency", "cb_currency", "entry_moneda") or "RD$"
        print(f"[DEBUG] moneda -> {moneda!r}")

        # 6) Tipo NCF / Categoría
        tipo_ncf = self._get_from_entries(["tipo de factura", "tipo de ncf", "tipo ncf"]) \
                or self._val_from_widget("combo_ncf_type", "cmb_ncf_type", "cb_ncf_type", "entry_tipo_ncf")
        categoria = self._get_from_entries(["categoría", "categoria"]) \
                    or self._val_from_widget("combo_category", "cmb_category", "cb_category", "entry_categoria")
        print(f"[DEBUG] tipo_ncf={tipo_ncf!r} categoría={categoria!r}")

        # 7) Números
        itbis = self._get_from_entries(["itbis"]) \
                or self._val_from_widget("entry_itbis", "ent_itbis", "txt_itbis", "var_itbis", default="0")
        total = self._get_from_entries(["factura total", "monto total", "total", "total factura"]) \
                or self._val_from_widget("entry_total", "ent_total", "txt_total", "var_total", default="0")
        tasa  = self._get_from_entries(["tasa", "tasa de cambio", "tasa cambio"]) \
                or self._val_from_widget("entry_exchange_rate", "ent_exchange_rate", "txt_exchange_rate", "var_exchange_rate", default="1")

        itbis = self._parse_decimal(itbis)
        total = self._parse_decimal(total)
        tasa  = self._parse_decimal(tasa)
        print(f"[DEBUG] itbis={itbis} total={total} tasa={tasa}")

        data = {
            "número_de_factura": numero,
            "rnc_cédula": rnc,
            "empresa_a_la_que_se_emitió": tercero,
            "lugar_de_compra_empresa": tercero,
            "fecha_factura": fecha_factura,
            "fecha_imputación": fecha_imput,
            "moneda": moneda,
            "tipo_ncf": tipo_ncf,
            "categoría": categoria,
            "itbis": itbis,
            "monto_total": total,
            "tasa_cambio": tasa,
        }
        return data



    def _build_form(self, frame_text, third_party_label):
        form_frame = ttk.LabelFrame(self, text=frame_text, padding=(15, 10))
        form_frame.pack(padx=15, pady=15, fill="both", expand=True)

        # --- NUEVO BOTÓN PARA CARGAR Y VER ANEXO ---
        if self.invoice_type == 'gasto':
            ttk.Button(form_frame, text="Cargar y Ver Anexo para Imputar Datos...", command=self._load_and_show_attachment, style="Accent.TButton").grid(row=0, column=0, columnspan=4, sticky="ew", pady=(0, 15))
        
        fields = {"Fecha:": (DateEntry, {'width': 18, 'date_pattern': 'yyyy-mm-dd', 'state': 'readonly'})}
        if self.invoice_type == 'emitida':
            fields["Tipo de Factura:"] = (ttk.Combobox, {'values': ["Factura Privada", "Gubernamental", "Exenta", "Consumo"], 'state': 'readonly'})
        fields.update({
            "Número de Factura:": (ttk.Entry, {}), "Moneda:": (ttk.Combobox, {'values': self.controller.get_all_currencies(), 'state': 'readonly'}),
            "RNC/Cédula:": (ttk.Entry, {}), third_party_label: (ttk.Entry, {})
        })
        
        row_index = 1 # Empezamos en la fila 1 por el nuevo botón
        for label_text, (widget_class, opts) in fields.items():
            ttk.Label(form_frame, text=label_text).grid(row=row_index, column=0, columnspan=2, padx=5, pady=6, sticky="w")
            widget = widget_class(form_frame, **opts)
            widget.grid(row=row_index, column=2, columnspan=2, padx=5, pady=6, sticky="ew")
            key = label_text.replace(":", "").replace(" ", "_").replace("/", "_").lower()
            self.entries[key] = widget
            if isinstance(widget, ttk.Combobox) and not self.existing_data: widget.set(opts['values'][0])
            row_index += 1
        
        # (El resto del _build_form se mantiene igual, con la sección de adjuntar al final)
        self.suggestion_listbox = tk.Listbox(form_frame, height=4)
        self.suggestion_listbox.grid(row=row_index, column=2, columnspan=2, sticky="nsew", padx=5); self.suggestion_listbox.grid_remove()
        row_index += 1
        numeric_fields = {"ITBIS:": 'itbis', "Factura Total:": 'factura_total'}
        for label, key in numeric_fields.items():
            ttk.Label(form_frame, text=label).grid(row=row_index, column=0, columnspan=2, padx=5, pady=6, sticky="w")
            entry = ttk.Entry(form_frame)
            entry.grid(row=row_index, column=2, padx=5, pady=6, sticky="ew")
            self.entries[key] = entry
            btn_opts = {'command': lambda e=entry: self._open_mini_calc(e)}
            if self.calc_icon: btn_opts['image'] = self.calc_icon
            else: btn_opts.update({'text': '...', 'width': 3})
            ttk.Button(form_frame, **btn_opts).grid(row=row_index, column=3, padx=(0, 5))
            row_index += 1
        if self.invoice_type == 'gasto':
            ttk.Separator(form_frame, orient='horizontal').grid(row=row_index, column=0, columnspan=4, sticky="ew", pady=10)
            row_index += 1
            ttk.Label(form_frame, text="Comprobante Adjunto:").grid(row=row_index, column=0, columnspan=2, sticky="w", padx=5)
            self.attachment_label = ttk.Label(form_frame, textvariable=self.attachment_relative_path, font=("Arial", 8, "italic"), foreground="blue", wraplength=350)
            self.attachment_label.grid(row=row_index, column=2, sticky="ew", padx=5)
            row_index += 1
            btn_frame = ttk.Frame(form_frame)
            btn_frame.grid(row=row_index, column=2, columnspan=2, sticky="w", padx=5, pady=5)
            ttk.Button(btn_frame, text="Adjuntar sin ver...", command=self._attach_file).pack(side="left")
            ttk.Button(btn_frame, text="Quitar", command=lambda: self.attachment_relative_path.set("")).pack(side="left", padx=5)
            row_index += 1

        self.entries['rnc_cédula'].bind("<KeyRelease>", lambda e: self._on_keyup(e, 'rnc'))
        self.entries[third_party_label.replace(":", "").replace(" ", "_").replace("/", "_").lower()].bind("<KeyRelease>", lambda e: self._on_keyup(e, 'name'))
        self.suggestion_listbox.bind("<<ListboxSelect>>", lambda e, lbl=third_party_label: self._on_suggestion_select(e, lbl))
        form_frame.columnconfigure(2, weight=1)
        save_button = ttk.Button(form_frame, text="Guardar Cambios", command=self._on_save)
        save_button.grid(row=row_index, column=0, columnspan=4, pady=20, ipady=5)


    def _process_attachment(self, source_path):
        """Función centralizada para copiar archivo y devolver la ruta completa. Guarda la ruta de anexos si el destino cambia."""
        try:
            active_company_name = self.parent.company_selector_var.get()
            invoice_date = self.entries['fecha'].get_date()
            destination_folder = self.controller.ensure_attachment_folder_exists(active_company_name, invoice_date)
            
            # Si la carpeta de anexos no existe, pregunta y guarda en config
            if not destination_folder or not os.path.isdir(destination_folder):
                attachment_path = filedialog.askdirectory(title="Selecciona la carpeta raíz de anexos (Dropbox u otra)")
                if attachment_path and os.path.isdir(attachment_path):
                    # Guarda en config global
                    config = config_manager.load_config()
                    config['carpeta_destino'] = attachment_path
                    config['attachment_base_path'] = attachment_path
                    config_manager.save_config(config)
                    # Guarda en empresa activa
                    empresa_cfg = config_manager.get_empresa_config(self.parent.company_rnc)
                    if empresa_cfg is not None:
                        empresa_cfg['carpeta_destino'] = attachment_path
                        config_manager.set_empresa_config(self.parent.company_rnc, empresa_cfg)
                    destination_folder = attachment_path
                else:
                    messagebox.showerror("Error de Configuración", "No se pudo determinar la carpeta de destino.\n\nAsegúrate de haber configurado la 'Carpeta de Destino' en Configuración.", parent=self)
                    return None

            filename = os.path.basename(source_path)
            destination_path = os.path.join(destination_folder, filename)
            
            if os.path.exists(destination_path) and not messagebox.askyesno("Archivo Duplicado", f"El archivo '{filename}' ya existe.\n¿Deseas sobreescribirlo?", parent=self):
                return None
            
            shutil.copy(source_path, destination_path)
            base_path = self.controller.get_setting('attachment_base_path')

            print(f"[DEBUG] Ruta de Destino Completa: {destination_path}")
            print(f"[DEBUG] Carpeta Raíz (Base): {base_path}")

            relative_path = os.path.relpath(destination_path, base_path)
            self.attachment_relative_path.set(relative_path.replace("\\", "/"))
            return destination_path
            
        except Exception as e:
            messagebox.showerror("Error al Adjuntar", f"No se pudo copiar el archivo: {e}", parent=self)
            return None

    def _load_and_show_attachment(self):
        initial_dir = self.controller.get_setting('downloads_folder_path')
        # Si la carpeta de origen no existe, pregunta y guarda en config y empresa activa
        if not initial_dir or not os.path.isdir(initial_dir):
            downloads_path = filedialog.askdirectory(title="Selecciona la carpeta de Descargas")
            if downloads_path and os.path.isdir(downloads_path):
                config = config_manager.load_config()
                config['downloads_folder_path'] = downloads_path
                config_manager.save_config(config)
                empresa_cfg = config_manager.get_empresa_config(self.parent.company_rnc)
                if empresa_cfg is not None:
                    empresa_cfg['carpeta_origen'] = downloads_path
                    config_manager.set_empresa_config(self.parent.company_rnc, empresa_cfg)
                initial_dir = downloads_path

        source_path = filedialog.askopenfilename(
            title="Selecciona el comprobante para ver y adjuntar",
            filetypes=[("Imágenes", "*.jpg *.jpeg *.png")],
            initialdir=initial_dir
        )
        if not source_path: return
        full_destination_path = self._process_attachment(source_path)
        if full_destination_path:
            AttachmentEditorWindow(self, full_destination_path)

    def _attach_file(self):
        initial_dir = self.controller.get_setting('downloads_folder_path')
        # Si la carpeta de origen no existe, pregunta y guarda en config y empresa activa
        if not initial_dir or not os.path.isdir(initial_dir):
            downloads_path = filedialog.askdirectory(title="Selecciona la carpeta de Descargas")
            if downloads_path and os.path.isdir(downloads_path):
                config = config_manager.load_config()
                config['downloads_folder_path'] = downloads_path
                config_manager.save_config(config)
                empresa_cfg = config_manager.get_empresa_config(self.parent.company_rnc)
                if empresa_cfg is not None:
                    empresa_cfg['carpeta_origen'] = downloads_path
                    config_manager.set_empresa_config(self.parent.company_rnc, empresa_cfg)
                initial_dir = downloads_path

        source_path = filedialog.askopenfilename(
            title="Selecciona el comprobante para adjuntar",
            filetypes=[("Comprobantes", "*.jpg *.jpeg *.png *.pdf")],
            initialdir=initial_dir
        )
        if not source_path: return
        self._process_attachment(source_path)
           
    def _on_save(self):
        """
        Recolecta datos del formulario e ítems y llama al callback del padre con la firma unificada:
        save_callback(parent_window, form_data, items_data, invoice_type, invoice_id)
        """
        try:
            form_data = self._collect_form_data()  # Asume que ya tienes este método; si no, usa el dict que armas actualmente.
            items_data = self._collect_items_data()

            # Validación mínima local (también se valida en el callback)
            if not form_data.get("número_de_factura", "").strip():
                messagebox.showerror("Campo Vacío", "El campo 'Número de Factura' no puede estar vacío.", parent=self)
                return
            if not form_data.get("rnc_cédula", "").strip():
                messagebox.showerror("Campo Vacío", "El campo 'RNC/Cédula' no puede estar vacío.", parent=self)
                return

            # Firma unificada: incluye items_data y el parent_window (self)
            self.save_callback(
                self,                     # parent_window
                form_data,                # dict con campos de la factura
                items_data,               # lista de renglones
                self.invoice_type,        # 'emitida' | 'gasto'
                getattr(self, "invoice_id", None)  # None o id existente
            )
        except Exception as e:
            messagebox.showerror("Error", f"Ocurrió un error recopilando la información: {e}", parent=self)


    def _open_mini_calc(self, target_entry): MiniCalculator(self, target_entry)
    def _on_keyup(self, event, search_by):
        query = event.widget.get()
        if len(query) < 2: self.suggestion_listbox.grid_remove(); return
        results = self.controller.search_third_parties(query, search_by=search_by)
        self.suggestion_listbox.delete(0, tk.END)
        if results:
            self.suggestion_listbox.grid(); [self.suggestion_listbox.insert(tk.END, f"{i['rnc']} - {i['name']}") for i in results]
        else: self.suggestion_listbox.grid_remove()
    def _on_suggestion_select(self, event, third_party_label_text):
        if not self.suggestion_listbox.curselection(): return
        selection = self.suggestion_listbox.get(self.suggestion_listbox.curselection()); rnc, name = selection.split(' - ', 1)
        key = third_party_label_text.replace(":", "").replace(" ", "_").replace("/", "_").lower()
        self.entries['rnc_cédula'].delete(0, tk.END); self.entries['rnc_cédula'].insert(0, rnc)
        self.entries[key].delete(0, tk.END); self.entries[key].insert(0, name)
        self.suggestion_listbox.grid_remove()

    def _collect_items_data(self):
        """
        Devuelve una lista de dicts con los renglones:
        [{'description': str, 'quantity': float, 'unit_price': float}, ...]
        Adapta a cómo tengas tu Treeview o controles.
        """
        items = []
        try:
            for iid in getattr(self, "tree_items", []).get_children():
                vals = self.tree_items.item(iid, "values")
                desc = (vals[0] if len(vals) > 0 else "").strip()
                qty  = self._parse_decimal(vals[1]) if len(vals) > 1 else 0.0
                up   = self._parse_decimal(vals[2]) if len(vals) > 2 else 0.0
                if desc:
                    items.append({
                        "description": desc,
                        "quantity": float(qty),
                        "unit_price": float(up)
                    })
        except Exception:
            pass
        return items
    


    def _guess_invoice_number(self):
        # 1) Intentos directos por nombres comunes
        candidates = [
            # Nuevos nombres típicos en ventanas de edición
            "entry_invoice_number_edit", "ent_invoice_number_edit", "txt_invoice_number_edit",
            "entry_numero_factura_edit", "ent_numero_factura_edit", "txt_numero_factura_edit",
            "entry_ncf_edit", "ent_ncf_edit", "txt_ncf_edit",
            # Genéricos anteriores
            "entry_invoice_number", "ent_invoice_number", "txt_invoice_number",
            "entry_numero_factura", "ent_numero_factura", "txt_numero_factura",
            "entry_ncf", "ent_ncf", "txt_ncf", "ncf_entry", "invoice_number_entry",
            "entry_invoice_ncf", "ent_invoice_ncf", "txt_invoice_ncf",
            # Variables
            "var_invoice_number", "var_numero_factura", "var_ncf"
        ]
        for name in candidates:
            val = self._val_from_widget(name)
            if val:
                return val

        # 2) Barrido genérico de todo lo que tenga .get()
        #    Captura NCF tipo B01000000115 (letra + >=10 dígitos)
        pat_strong = re.compile(r"[A-Za-z][0-9]{6,}")     # letra seguida de varios números
        pat_loose  = re.compile(r"[A-Za-z]\w{5,}")       # más laxo
        try:
            for attr_name in dir(self):
                try:
                    obj = getattr(self, attr_name)
                except Exception:
                    continue
                if hasattr(obj, "get") and callable(getattr(obj, "get")):
                    try:
                        val = obj.get()
                        if isinstance(val, (str, int, float)):
                            sval = str(val).strip()
                            if sval and (pat_strong.search(sval) or pat_loose.search(sval)):
                                return sval
                    except Exception:
                        pass
        except Exception:
            pass

        # 3) Últimos recursos: atributos sueltos
        for fallback in ("invoice_number", "ncf", "numero_factura"):
            if hasattr(self, fallback):
                try:
                    sval = str(getattr(self, fallback) or "").strip()
                    if sval:
                        return sval
                except Exception:
                    pass

        return ""

    def _entries_keys(self):
        """Devuelve lista de claves disponibles en self.entries para debug."""
        try:
            e = getattr(self, "entries", None)
            if isinstance(e, dict):
                return list(e.keys())
            if isinstance(e, (list, tuple)):
                # si es lista de (clave, widget) o solo widgets
                ks = []
                for item in e:
                    if isinstance(item, (list, tuple)) and len(item) >= 1:
                        ks.append(str(item[0]))
                return ks
        except Exception:
            pass
        return []

    def _get_from_entries(self, wanted_keys):
        """
        Busca valores en self.entries por etiqueta/clave.
        - wanted_keys: lista de strings (minúsculas) a buscar por igualdad o contención.
        Retorna str o "" si no encuentra.
        """
        e = getattr(self, "entries", None)
        if e is None:
            return ""
        # normaliza wanted_keys
        wanted = [wk.strip().lower() for wk in wanted_keys]

        def read_widget(w):
            try:
                if hasattr(w, "get") and callable(getattr(w, "get")):
                    v = w.get()
                    return "" if v is None else str(v).strip()
            except Exception:
                pass
            return ""

        # caso dict: { "Etiqueta": widget }
        if isinstance(e, dict):
            # búsqueda por match exacto o por contención
            for k, w in e.items():
                lk = str(k).strip().lower()
                for wk in wanted:
                    if lk == wk or wk in lk:
                        val = read_widget(w)
                        if val:
                            return val
            return ""

        # caso lista de pares [(clave, widget), ...] o lista de widgets
        if isinstance(e, (list, tuple)):
            for item in e:
                try:
                    if isinstance(item, (list, tuple)):
                        # (clave, widget)
                        if len(item) >= 2:
                            lk = str(item[0]).strip().lower()
                            w = item[1]
                            for wk in wanted:
                                if lk == wk or wk in lk:
                                    val = read_widget(w)
                                    if val:
                                        return val
                        else:
                            # probablemente solo widget
                            w = item[0]
                            val = read_widget(w)
                            if val:
                                # si no tenemos clave, devolvemos lo que haya
                                return val
                    else:
                        # widget suelto
                        val = read_widget(item)
                        if val:
                            return val
                except Exception:
                    pass
        return ""

    def _debug_dump_entries(self):
        print("[DEBUG] entries keys ->", self._entries_keys())

    def get_downloads_folder_path(self):
        """
        Devuelve la ruta de la carpeta de descargas, usando la configuración de la empresa activa.
        Si no existe, pregunta al usuario y la guarda en config y empresa activa.
        """
        import os
        from tkinter import filedialog, messagebox

        company_id = self.get_active_company_id_from_settings()
        empresa_cfg = config_manager.get_empresa_config(company_id)
        downloads_path = None
        if empresa_cfg and empresa_cfg.get('carpeta_origen'):
            downloads_path = empresa_cfg.get('carpeta_origen')
        else:
            config = config_manager.load_config()
            downloads_path = config.get('downloads_folder_path')

        if not downloads_path or not os.path.isdir(downloads_path):
            root_temp = tk.Tk(); root_temp.withdraw()
            messagebox.showinfo(
                "Seleccionar Carpeta de Descargas",
                "No se ha configurado la carpeta de descargas.\nPor favor, selecciona la carpeta donde se descargarán los comprobantes."
            )
            selected_path = filedialog.askdirectory(
                title="Selecciona la carpeta de Descargas"
            )
            root_temp.destroy()
            if selected_path and os.path.isdir(selected_path):
                config = config_manager.load_config()
                config['downloads_folder_path'] = selected_path
                config_manager.save_config(config)
                if empresa_cfg is not None:
                    empresa_cfg['carpeta_origen'] = selected_path
                    config_manager.set_empresa_config(company_id, empresa_cfg)
                empresa_cfg = config_manager.get_empresa_config(company_id)
                downloads_path = empresa_cfg.get('carpeta_origen') if empresa_cfg else selected_path
                return downloads_path
            else:
                messagebox.showerror(
                    "Error de Configuración",
                    "No se seleccionó ninguna carpeta válida. No se puede continuar."
                )
                return None
        return downloads_path

### Archivo: app_gui.py

# app_gui.py
import tkinter as tk
from tkinter import ttk, messagebox, filedialog, scrolledtext
import os
from tkcalendar import DateEntry
import datetime
from tkinter import simpledialog
from add_invoice_window import AddInvoiceWindow
from report_window import ReportWindow
from retention_calculator_window import RetentionCalculatorWindow
from advanced_retention_window import AdvancedRetentionWindow
from tax_calculation_management_window import TaxCalculationManagementWindow
import shutil
import config_manager
from settings_window import SettingsWindow
from third_party_report_window import ThirdPartyReportWindow
from mini_calculator_window import MiniCalculator
from company_management_window import CompanyManagementWindow
from attachment_editor_window import AttachmentEditorWindow
from invoice_generator_window import InvoiceGeneratorWindow
from sqlite3 import IntegrityError
import re



class MainApplication(tk.Frame):
    """
    Clase principal para la interfaz gráfica de usuario (GUI).
    """
    def __init__(self, root, controller):
        super().__init__(root)  # <-- ¡Esto elimina el error!
        self.root = root
        self.controller = controller
        self.companies_list = [] # Lista de empresas con sus IDs
        self.current_transactions = [] # Lista de transacciones actual
        self.months_map = {
            'Enero': '01', 'Febrero': '02', 'Marzo': '03', 'Abril': '04',
            'Mayo': '05', 'Junio': '06', 'Julio': '07', 'Agosto': '08',
            'Septiembre': '09', 'Octubre': '10', 'Noviembre': '11', 'Diciembre': '12'
        }
        self.current_itbis_neto = 0.0
        self.itbis_adelantado_var = tk.StringVar(value="0.0")
        self.root.title("Asistente de Gestión de Facturas (v2.0)")
        self.root.geometry("1200x700")
        self.root.protocol("WM_DELETE_WINDOW", self._on_closing)
        self.pack(fill=tk.BOTH, expand=True)  # <-- Empaca el frame principal
        self._create_widgets()
        self._create_menubar()
        self._populate_company_selector()
        self._update_window_title()

        # Las empresas NO deben estar hardcodeadas, se deben poblar desde la base de datos en _populate_company_selector()

        # Inicializa el selector de empresa activa (Combobox)
        # El listado de empresas debe venir de la base de datos
        # self.company_selector = ttk.Combobox(self, values=list(self.name_to_rnc.keys()))
        # self.company_selector.pack()
        # self.company_selector.set("Barnhouse Services Srl")  # Por defecto

    def get_current_company_id(self):
        """
        Retorna el RNC real de la empresa activa (como clave del JSON)
        """
        selected_name = self.company_selector.get()
        return self.name_to_rnc.get(selected_name, "")

    def get_current_company_name(self):
        """
        Retorna el nombre de la empresa activa (lo que se muestra en el dashboard)
        """
        return self.company_selector.get()

    def _create_menubar(self):
        """Crea la barra de menú principal de la aplicación."""
        menubar = tk.Menu(self.root)
        self.root.config(menu=menubar)

        # --- Menú Archivo ---
        file_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Archivo", menu=file_menu)
        file_menu.add_command(label="Cambiar Base de Datos...", command=self._change_database)
        file_menu.add_separator()
        file_menu.add_command(label="Crear Copia de Seguridad...", command=self._backup_database)
        file_menu.add_command(label="Restaurar Copia de Seguridad...", command=self._restore_database)
        file_menu.add_separator()
        file_menu.add_command(label="Nueva Base de Datos...", command=self._create_new_database)
        file_menu.add_command(label="Abrir Base de Datos...", command=self._change_database) # Cambiamos el texto para mayor claridad
        file_menu.add_separator()
        file_menu.add_command(label="Salir", command=self._on_closing)
 
        
        # --- Menú Reportes (NUEVO) ---
        report_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Reportes", menu=report_menu)
        report_menu.add_command(label="Reporte Mensual...", command=self._open_report_window)
        report_menu.add_command(label="Reporte por Cliente/Proveedor...", command=self._open_third_party_report_window)

        # --- Menú Opciones ---
        options_menu = tk.Menu(menubar, tearoff=0)
        menubar.add_cascade(label="Opciones", menu=options_menu)
        options_menu.add_command(label="Gestionar Empresas...", command=self._open_company_management_window)
        options_menu.add_command(label="Configuración...", command=self._open_settings_window)
        options_menu.add_separator()
        theme_menu = tk.Menu(options_menu, tearoff=0)
        options_menu.add_cascade(label="Cambiar Tema", menu=theme_menu)
        available_themes = self.root.get_themes()
        recommended_themes = ['arc', 'elegance', 'plastik', 'clearlooks', 'radiance', 'scidblue']
        for theme in recommended_themes:
            if theme in available_themes:
                theme_menu.add_command(label=theme, command=lambda t=theme: self._change_theme(t))

    def _create_new_database(self):
        """Permite al usuario crear un nuevo archivo de base de datos."""
        new_path = filedialog.asksaveasfilename(
            title="Crear Nueva Base de Datos",
            initialfile="nueva_base_de_datos.db",
            defaultextension=".db",
            filetypes=[("Base de Datos SQLite", "*.db"), ("Todos los archivos", "*.*")],
            parent=self.root
        )
        if new_path:
            import os
            dir_path = os.path.dirname(new_path)
            if dir_path and not os.path.exists(dir_path):
                try:
                    os.makedirs(dir_path, exist_ok=True)
                except Exception as e:
                    messagebox.showerror(
                        "Error",
                        f"No se pudo crear la carpeta para la base de datos:\n{e}",
                        parent=self.root
                    )
                    return
            # Si aún no existe el archivo, créalo vacío
            if not os.path.exists(new_path):
                try:
                    open(new_path, 'a').close()
                except Exception as e:
                    messagebox.showerror(
                        "Error",
                        f"No se pudo crear el archivo de base de datos:\n{e}",
                        parent=self.root
                    )
                    return
            self._switch_database(new_path)
    def _create_widgets(self):
        # --- Frame Superior ---
        top_frame = ttk.Frame(self.root, padding="5 5 5 5")
        top_frame.pack(side=tk.TOP, fill=tk.X)
        ttk.Label(top_frame, text="Empresa Activa:", font=("Arial", 12, "bold")).pack(side=tk.LEFT, padx=(0, 10))
        self.company_selector_var = tk.StringVar()
        self.company_selector = ttk.Combobox(top_frame, textvariable=self.company_selector_var, font=("Arial", 12), width=40, state="readonly")
        self.company_selector.pack(side=tk.LEFT, padx=10, fill=tk.X, expand=True)
        self.company_selector.bind("<<ComboboxSelected>>", self._on_company_select)
        self.migrate_button = ttk.Button(top_frame, text="Migrar Datos (JSON)", command=self._perform_migration)
        self.migrate_button.pack(side=tk.RIGHT, padx=10)

        # --- PanedWindow para la división principal ---
        paned_window = tk.PanedWindow(self.root, orient=tk.HORIZONTAL, sashrelief=tk.RAISED)
        paned_window.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)

        # --- Panel Izquierdo ---
        left_pane = ttk.Frame(paned_window, relief=tk.SUNKEN)
        paned_window.add(left_pane, width=350)
        
        menu_frame = ttk.LabelFrame(left_pane, text="Opciones de Facturación", padding=10)
        menu_frame.pack(pady=10, padx=10, fill=tk.X)
        self.btn_add_emitida = ttk.Button(menu_frame, text="Registrar Factura Emitida (Ingreso)", command=self._open_add_emitted_window)
        self.btn_add_emitida.pack(pady=4, fill=tk.X, ipady=4)
        self.btn_generar_factura_excel = ttk.Button(menu_frame, text="Generador de Facturas (Excel)", command=self._show_in_progress)        
        self.btn_add_gasto = ttk.Button(menu_frame, text="Registrar Factura de Gasto", command=self._open_add_expense_window)
        self.btn_add_gasto.pack(pady=4, fill=tk.X, ipady=4)
        self.btn_generar_reporte = ttk.Button(menu_frame, text="Ver Reporte Mensual (Ventana)", command=self._open_report_window)
        self.btn_generar_reporte.pack(pady=4, fill=tk.X, ipady=4)
        
        self.btn_calculadora_retenciones = ttk.Button(menu_frame, text="Cálculo Impuestos y Retenciones", style="Accent.TButton", command=self._open_retention_calculator)
        self.btn_calculadora_retenciones.pack(pady=4, fill=tk.X, ipady=4)
        self.btn_mini_calc = ttk.Button(menu_frame, text="Mini Calculadora", command=self._open_mini_calculator)
        self.btn_mini_calc.pack(pady=4, fill=tk.X, ipady=4)

        style = ttk.Style(self.root)
        style.configure("Accent.TButton", foreground="black", background="lightblue")
        
        self.btn_salir = ttk.Button(menu_frame, text="Salir", command=self._on_closing)
        self.btn_salir.pack(pady=10, fill=tk.X, ipady=4)
        
        filter_frame = ttk.LabelFrame(left_pane, text="Filtros del Dashboard", padding=10)
        filter_frame.pack(pady=10, padx=10, fill=tk.BOTH, expand=True)
        ttk.Label(filter_frame, text="Por Mes y Año:", font=("Arial", 10, "bold")).grid(row=0, column=0, columnspan=2, sticky="w", pady=(0, 5))
        ttk.Label(filter_frame, text="Mes:").grid(row=1, column=0, sticky="w", padx=5)
        self.dashboard_mes_cb = ttk.Combobox(filter_frame, width=12, values=list(self.months_map.keys()), state="readonly")
        self.dashboard_mes_cb.grid(row=1, column=1, padx=5, sticky="ew")
        ttk.Label(filter_frame, text="Año:").grid(row=2, column=0, sticky="w", padx=5)
        self.dashboard_anio_entry = ttk.Combobox(filter_frame, width=12, state="readonly")
        self.dashboard_anio_entry.grid(row=2, column=1, padx=5, sticky="ew")
        ttk.Label(filter_frame, text="Por Fecha Específica:", font=("Arial", 10, "bold")).grid(row=3, column=0, columnspan=2, sticky="w", pady=(10, 5))
        self.date_filter_entry = DateEntry(filter_frame, width=12, date_pattern='yyyy-mm-dd', state="readonly")
        self.date_filter_entry.grid(row=4, column=0, columnspan=2, sticky="w", padx=5)
        self.date_filter_entry.set_date(None)
        self.date_filter_entry.bind("<<DateEntrySelected>>", self._on_date_select)
        ttk.Button(filter_frame, text="Aplicar Filtro Mes/Año", command=self._apply_month_year_filter).grid(row=5, column=0, columnspan=2, pady=5, sticky="ew")
        ttk.Button(filter_frame, text="Ver Todo / Limpiar Filtros", command=self._clear_all_filters).grid(row=6, column=0, columnspan=2, pady=5, sticky="ew")

        # --- Panel Derecho ---
        right_pane = ttk.Frame(paned_window, relief=tk.SUNKEN)
        paned_window.add(right_pane)

        # -- Sub-panel de Resumen --
        summary_frame = ttk.LabelFrame(right_pane, text="Resumen Financiero Actual", padding=15)
        summary_frame.pack(padx=10, pady=10, fill=tk.X)
        
        self.summary_widgets = {}
        summary_info = {
            "Total Ingresos": {"row": 0, "col": 0}, "ITBIS Ingresos": {"row": 0, "col": 2},
            "Total Gastos":   {"row": 1, "col": 0}, "ITBIS Gastos":   {"row": 1, "col": 2}
        }
        for text, props in summary_info.items():
            ttk.Label(summary_frame, text=f"{text}:", font=("Arial", 11)).grid(row=props["row"], column=props["col"], sticky="w", padx=5, pady=3)
            value_label = ttk.Label(summary_frame, text="RD$ 0.00", font=("Arial", 11, "bold"))
            value_label.grid(row=props["row"], column=props["col"] + 1, sticky="e", padx=5, pady=3)
            self.summary_widgets[text] = value_label

        ttk.Label(summary_frame, text="ITBIS Adelantado (Mes Ant.):", font=("Arial", 11)).grid(row=2, column=0, sticky="w", padx=5, pady=3)
        entry_widget = ttk.Entry(summary_frame, textvariable=self.itbis_adelantado_var, font=("Arial", 11, "bold"), width=15, justify='right')
        entry_widget.grid(row=2, column=1, sticky="e", padx=5, pady=3)

        ttk.Label(summary_frame, text="ITBIS a Pagar (Restante):", font=("Arial", 12, "bold")).grid(row=3, column=0, sticky="w", padx=5, pady=3)
        itbis_pagar_label = ttk.Label(summary_frame, text="RD$ 0.00", font=("Arial", 12, "bold"))
        itbis_pagar_label.grid(row=3, column=1, sticky="e", padx=5, pady=3)
        self.summary_widgets["ITBIS a Pagar"] = itbis_pagar_label
        
        btn_calcular = ttk.Button(summary_frame, text="Calcular", style="Accent.TButton", command=self._recalculate_itbis_restante)
        btn_calcular.grid(row=3, column=2, padx=(10, 5), pady=3, sticky="w")

        ttk.Separator(summary_frame, orient='horizontal').grid(row=4, column=0, columnspan=4, sticky="ew", pady=8)
        ttk.Label(summary_frame, text="ITBIS Neto:", font=("Arial", 12, "bold", "underline")).grid(row=5, column=0, sticky="w", padx=5, pady=3)
        neto_label = ttk.Label(summary_frame, text="RD$ 0.00", font=("Arial", 12, "bold", "underline"))
        neto_label.grid(row=5, column=1, sticky="e", padx=5, pady=3)
        self.summary_widgets["ITBIS Neto"] = neto_label
        
        ttk.Label(summary_frame, text="Total Neto:", font=("Arial", 12, "bold", "underline")).grid(row=5, column=2, sticky="w", padx=5, pady=3)
        total_neto_label = ttk.Label(summary_frame, text="RD$ 0.00", font=("Arial", 12, "bold", "underline"))
        total_neto_label.grid(row=5, column=3, sticky="e", padx=5, pady=3)
        self.summary_widgets["Total Neto"] = total_neto_label

        summary_frame.columnconfigure(1, weight=1)
        summary_frame.columnconfigure(3, weight=1)

        # -- Sub-panel de Transacciones (AHORA CON TREEVIEW) --
        trans_frame = ttk.LabelFrame(right_pane, text="Transacciones", padding=10)
        trans_frame.pack(padx=10, pady=10, fill=tk.BOTH, expand=True)

        # -- Filtro para la tabla --
        filter_bar = ttk.Frame(trans_frame)
        filter_bar.pack(fill=tk.X, pady=(0, 5))
        ttk.Label(filter_bar, text="Mostrar:", font=("Arial", 10)).pack(side=tk.LEFT)
        self.transaction_filter_var = tk.StringVar(value="Todos")
        self.transaction_filter = ttk.Combobox(
            filter_bar, textvariable=self.transaction_filter_var, 
            values=["Todos", "Ingresos", "Gastos"], state="readonly", width=12
        )
        self.transaction_filter.pack(side=tk.LEFT, padx=5)
        self.transaction_filter.bind("<<ComboboxSelected>>", self._apply_transaction_filter)

        # -- Tabla (Treeview) --
        columns = ('Fecha', 'Tipo', 'No. Fact.', 'Empresa', 'ITBIS (RD$)', 'Monto Original', 'Total RD$')
        self.transactions_tree = ttk.Treeview(trans_frame, columns=columns, show='headings')
        self.context_menu = tk.Menu(self.root, tearoff=0)
        self.context_menu.add_command(label="Modificar Transacción", command=self._edit_selected_invoice)
        self.context_menu.add_command(label="Editar Anexo...", command=self._open_attachment_editor)
        self.context_menu.add_separator() 
        self.context_menu.add_command(label="Eliminar Transacción", command=self._delete_selected_invoice)
        
        self.transactions_tree.bind("<Button-3>", self._show_context_menu) # Clic derecho
        self.transactions_tree.bind("<Double-1>", self._edit_selected_invoice) # Doble clic

        # Definir encabezados y anchos de columna
        self.transactions_tree.heading('Fecha', text='Fecha')
        self.transactions_tree.column('Fecha', width=90, anchor='w')
        self.transactions_tree.heading('Tipo', text='Tipo')
        self.transactions_tree.column('Tipo', width=80, anchor='w')
        self.transactions_tree.heading('No. Fact.', text='No. Factura')
        self.transactions_tree.column('No. Fact.', width=120, anchor='w')
        self.transactions_tree.heading('Empresa', text='Empresa')
        self.transactions_tree.column('Empresa', width=250, anchor='w')
        self.transactions_tree.heading('ITBIS (RD$)', text='ITBIS (RD$)')
        self.transactions_tree.column('ITBIS (RD$)', width=100, anchor='e')
        self.transactions_tree.heading('Monto Original', text='Monto Original')
        self.transactions_tree.column('Monto Original', width=120, anchor='e')
        self.transactions_tree.heading('Total RD$', text='Total (RD$)')
        self.transactions_tree.column('Total RD$', width=120, anchor='e')
        
        # Scrollbar para la tabla
        scrollbar = ttk.Scrollbar(trans_frame, orient=tk.VERTICAL, command=self.transactions_tree.yview)
        self.transactions_tree.configure(yscrollcommand=scrollbar.set)
        
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.transactions_tree.pack(fill=tk.BOTH, expand=True)

        # --- Campo de búsqueda avanzada ---
        search_frame = ttk.Frame(trans_frame)
        search_frame.pack(fill=tk.X, pady=(0, 5))
        ttk.Label(search_frame, text="Buscar:").pack(side=tk.LEFT)
        self.search_var = tk.StringVar()
        search_entry = ttk.Entry(search_frame, textvariable=self.search_var)
        search_entry.pack(side=tk.LEFT, fill=tk.X, expand=True)
        search_entry.bind("<KeyRelease>", self._on_search_transactions)

        # --- Columnas ordenables ---
        for col in self.transactions_tree["columns"]:
            self.transactions_tree.heading(col, text=col,
                command=lambda c=col: self._sort_transactions_tree_by_column(c, False))


    def _show_in_progress(self):
        import tkinter.messagebox as messagebox
        messagebox.showinfo(
            "Función en Proceso",
            "La función 'Generador de Facturas (Excel)' está en proceso.\nPróximamente estará disponible."
        )


    def _on_search_transactions(self, event=None):
        term = self.search_var.get().lower().strip()
        if not term:
            self._apply_transaction_filter()
            return

        terms = term.split()
        filtered = []
        for t in self.current_transactions:
            row_text = (
                str(t['invoice_number']).lower()
                + " " + str(t['third_party_name']).lower()
                + " " + str(t['invoice_date']).lower()
                + " " + str(t['total_amount']).lower()
                + " " + str(t['total_amount_rd']).lower()
                + " " + str(t.get('rnc', '')).lower()
                + " " + str(t.get('invoice_category', '')).lower()
            )
            if all(term in row_text for term in terms):
                filtered.append(t)
        self._populate_transactions_tree(filtered)

    def _sort_transactions_tree_by_column(self, col, reverse):
        # Obtener todos los valores y ordenarlos
        data = [self.transactions_tree.item(iid)["values"] for iid in self.transactions_tree.get_children()]
        col_index = self.transactions_tree["columns"].index(col)
        # Detecta si la columna es numérica, fecha o texto
        def try_convert(val):
            # Para fechas tipo YYYY-MM-DD
            if "-" in str(val) and len(str(val)) == 10:
                return str(val)
            # Para números, elimina moneda y separadores
            try:
                val_num = str(val).replace(",", "").replace("RD$", "").replace(" ", "")
                return float(val_num)
            except Exception:
                return str(val)
        # Convierte todo a string si hay mezcla de tipos
        try:
            data.sort(key=lambda x: try_convert(x[col_index]), reverse=reverse)
        except TypeError:
            # Si falla, ordena como texto
            data.sort(key=lambda x: str(x[col_index]), reverse=reverse)
        # Limpiar y volver a insertar
        for iid in self.transactions_tree.get_children():
            self.transactions_tree.delete(iid)
        for row in data:
            self.transactions_tree.insert('', tk.END, values=row)
        # Cambia el orden al hacer clic de nuevo
        self.transactions_tree.heading(col, command=lambda c=col: self._sort_transactions_tree_by_column(c, not reverse))

    def _on_search_transactions(self, event=None):
        term = self.search_var.get().lower().strip()
        if not term:
            self._apply_transaction_filter()
            return
        filtered = []
        for t in self.current_transactions:
            if (
                term in t['invoice_number'].lower() or
                term in t['third_party_name'].lower() or
                term in t['invoice_date'].lower() or
                term in str(t['total_amount']) or
                term in str(t['total_amount_rd'])
            ):
                filtered.append(t)
        self._populate_transactions_tree(filtered)
    def _perform_migration(self):
        file_paths = filedialog.askopenfilenames(
            title="Selecciona los archivos JSON a migrar",
            filetypes=[("Archivos JSON", "*.json"), ("Todos los archivos", "*.*")], parent=self.root
        )
        if not file_paths:
            messagebox.showinfo("Cancelado", "La operación de migración fue cancelada.", parent=self.root)
            return

        confirm = messagebox.askyesno("Confirmar Migración", f"Se seleccionaron {len(file_paths)} archivos. ¿Deseas importarlos?", parent=self.root)
        if confirm:
            success, message = self.controller.migrate_from_json(file_paths)
            if success:
                messagebox.showinfo("Éxito", message, parent=self.root)
                self._populate_company_selector()
            else:
                messagebox.showerror("Error de Migración", message, parent=self.root)

    def _populate_company_selector(self):
        # Obtiene las empresas dinámicamente desde la base de datos/controlador
        self.companies_list = self.controller.get_all_companies()  # [{ 'id': ..., 'name': ..., 'rnc': ... }, ...]
        self.name_to_rnc = {c['name']: c['rnc'] for c in self.companies_list}
        self.rnc_to_name = {c['rnc']: c['name'] for c in self.companies_list}
        company_names = list(self.name_to_rnc.keys())
        if not hasattr(self, 'company_selector'):
            self.company_selector_var = tk.StringVar()
            self.company_selector = ttk.Combobox(self, textvariable=self.company_selector_var, values=company_names, state='readonly', font=("Arial", 12))
            self.company_selector.pack()
            self.company_selector.bind("<<ComboboxSelected>>", self._on_company_select)
        else:
            self.company_selector['values'] = company_names
        if company_names:
            self.company_selector.current(0)
            self._on_company_select()

    def _on_company_select(self, event=None):
        """
        Maneja la selección de una nueva empresa:
        - Habilita menús
        - Garantiza carpeta de anexos del mes actual
        - Persiste empresa activa en settings
        - Limpia filtros y refresca el dashboard
        """
        try:
            self._set_menu_state("normal")
        except Exception:
            pass

        # 1) Resolver nombre seleccionado (soporta tanto StringVar como el propio combobox)
        selected_name = ""
        try:
            if hasattr(self, "company_selector_var"):
                selected_name = (self.company_selector_var.get() or "").strip()
        except Exception:
            pass
        if not selected_name:
            try:
                if hasattr(self, "company_selector") and hasattr(self.company_selector, "get"):
                    selected_name = (self.company_selector.get() or "").strip()
            except Exception:
                pass

        if not selected_name:
            # No hay empresa seleccionada: deshabilitar menús y limpiar tablero
            try:
                self._set_menu_state("disabled")
            except Exception:
                pass
            try:
                self._clear_all_filters()
            except Exception:
                pass
            self._d("_on_company_select: sin empresa seleccionada")
            return

        self._d("_on_company_select: empresa seleccionada ->", selected_name)

        # 2) Asegurar carpeta de anexos del mes actual (si el controlador lo soporta)
        try:
            self.controller.ensure_attachment_folder_exists(selected_name, datetime.date.today())
            self._d("Carpeta de anexos verificada/creada para:", selected_name)
        except Exception as e:
            self._d("No se pudo asegurar carpeta de anexos:", e)

        # 3) Persistir empresa activa en tabla settings
        try:
            db = self._resolve_db()
            row = db.get_company_by_name(selected_name)
            if row:
                try:
                    company_id = int(row["id"])
                except Exception:
                    company_id = int(row[0])

                # Guardar en settings (upsert)
                cur = db.conn.cursor()
                cur.execute(
                    "INSERT INTO settings(key,value) VALUES('active_company_id', ?) "
                    "ON CONFLICT(key) DO UPDATE SET value=excluded.value",
                    (str(company_id),)
                )
                db.conn.commit()
                self._d("Empresa activa guardada en settings ->", company_id)

                # (Opcional) Mantener atributos internos coherentes
                try:
                    self.current_company_id = company_id
                    self.active_company_id = company_id
                    if isinstance(row, dict):
                        self.active_company = {"id": company_id, "name": selected_name}
                    else:
                        self.active_company = {"id": company_id, "name": selected_name}
                except Exception:
                    pass
            else:
                self._d("No se encontró la empresa en BD al persistir settings:", selected_name)
        except Exception as e:
            self._d("Error al persistir empresa activa en settings:", e)

        # 4) Limpiar filtros y refrescar dashboard (esto a su vez invoca _refresh_dashboard())
        try:
            self._clear_all_filters()  # Muestra todo por defecto para la nueva empresa
        except Exception as e:
            self._d("Error al limpiar filtros / refrescar dashboard:", e)


    def _update_summary_panel(self, summary_data):
        """Actualiza los widgets del panel de resumen financiero."""
        # Guardamos el valor numérico del ITBIS Neto para usarlo en el cálculo
        self.current_itbis_neto = summary_data['itbis_neto']
        
        # Actualizar labels
        self.summary_widgets["Total Ingresos"].config(text=f"RD$ {summary_data['total_ingresos']:,.2f}", foreground="#006400")
        self.summary_widgets["ITBIS Ingresos"].config(text=f"RD$ {summary_data['itbis_ingresos']:,.2f}", foreground="#006400")
        self.summary_widgets["Total Gastos"].config(text=f"RD$ {summary_data['total_gastos']:,.2f}", foreground="#C70039")
        self.summary_widgets["ITBIS Gastos"].config(text=f"RD$ {summary_data['itbis_gastos']:,.2f}", foreground="#C70039")
        self.summary_widgets["Total Neto"].config(text=f"RD$ {summary_data['total_neto']:,.2f}", foreground="blue")
        self.summary_widgets["ITBIS Neto"].config(text=f"RD$ {summary_data['itbis_neto']:,.2f}", foreground="blue")

        # Obtener el ID de la empresa actual para buscar su ITBIS adelantado
        selected_name = self.company_selector_var.get()
        company_id = next((c['id'] for c in self.companies_list if c['name'] == selected_name), None)

        if company_id:
            itbis_adelantado = self.controller.get_itbis_adelantado(company_id)
            self.itbis_adelantado_var.set(f"{itbis_adelantado:.2f}")

        # Recalcular el ITBIS a pagar con los nuevos datos
        self._recalculate_itbis_restante()

    def _apply_transaction_filter(self, event=None):
        """Filtra la lista de transacciones y llama a la función para poblar la tabla."""
        filter_value = self.transaction_filter_var.get()
        
        if filter_value == "Ingresos":
            filtered_list = [t for t in self.current_transactions if t['invoice_type'] == 'emitida']
        elif filter_value == "Gastos":
            filtered_list = [t for t in self.current_transactions if t['invoice_type'] == 'gasto']
        else: # "Todos"
            filtered_list = self.current_transactions
            
        self._populate_transactions_tree(filtered_list)



    def _populate_transactions_tree(self, transactions):
        for item in self.transactions_tree.get_children():
            self.transactions_tree.delete(item)
        
        for trans in transactions:
            itbis_rd = trans['itbis'] * trans['exchange_rate']
            monto_original_str = f"{trans['total_amount']:,.2f} {trans['currency']}"
            # Elige el texto con flecha para la columna "Tipo"
            if trans['invoice_type'] == 'emitida':
                tipo_texto = "↑ INGRESO"
                tag = 'ingreso'
            else:
                tipo_texto = "↓ GASTO"
                tag = 'gasto'

            row_values = (
                trans['invoice_date'],
                tipo_texto,
                trans['invoice_number'],
                trans['third_party_name'],
                f"{itbis_rd:,.2f}",
                monto_original_str,
                f"{trans['total_amount_rd']:,.2f}"
            )
            self.transactions_tree.insert('', tk.END, values=row_values, tags=(tag,), iid=trans['id'])

        # Configura colores de fondo de filas (opcional, ya lo tienes)
        self.transactions_tree.tag_configure('ingreso', background='#E8F8F5')
        self.transactions_tree.tag_configure('gasto', background='#FDEDEC')

    def _on_closing(self):
        print("Cerrando la aplicación...")
        self.controller.close_connection()
        self.root.destroy()


    def _placeholder(self):
        """Función temporal para botones no implementados."""
        messagebox.showinfo("Información", "Esta función aún no ha sido implementada.", parent=self.root)

    def _set_menu_state(self, state):
        """Habilita o deshabilita los botones del menú principal."""
        self.btn_add_emitida.config(state=state)
        self.btn_add_gasto.config(state=state)
        self.btn_generar_reporte.config(state=state)
        #self.btn_gestionar_transacciones.config(state=state)
        self.btn_calculadora_retenciones.config(state=state)

    def _apply_month_year_filter(self):
        """Valida la entrada y llama a refrescar el dashboard con los filtros de mes/año."""
        self.date_filter_entry.set_date(None) # <-- AÑADE ESTA LÍNEA
        mes_nombre = self.dashboard_mes_cb.get()
        anio_str = self.dashboard_anio_entry.get()

        try:
            if not mes_nombre or not anio_str:
                raise ValueError("El mes y el año son requeridos.")
            
            # Traducir nombre del mes a número
            mes_numero = self.months_map.get(mes_nombre)
            anio = int(anio_str)

            if not (mes_numero and 1900 < anio <= 2100):
                raise ValueError("El mes o el año introducidos no son válidos.")

            # Refrescamos el dashboard con los filtros
            self._refresh_dashboard(filter_month=mes_numero, filter_year=anio)

        except (ValueError, TypeError) as e:
            messagebox.showerror("Error de Entrada", str(e), parent=self.root)

    def _clear_all_filters(self):
        """Limpia los widgets de filtro y refresca el dashboard para mostrar todos los datos."""
        self.dashboard_mes_cb.set('')
        self.dashboard_anio_entry.set('') # Usamos set('') para combobox
        self.date_filter_entry.set_date(None)
        
        # Refresca el dashboard sin filtros
        self._refresh_dashboard()


    def _refresh_dashboard(self, filter_month=None, filter_year=None, specific_date=None):
        selected_name = self.company_selector_var.get()
        print("[REFRESH DASHBOARD] Empresa seleccionada:", selected_name)
        company_id = None
        for company in self.companies_list:
            if company['name'] == selected_name:
                company_id = company['id']
                break
        print("[REFRESH DASHBOARD] company_id usado:", company_id)
        if company_id is not None:
            dashboard_data = self.controller.get_dashboard_data(
                company_id,
                filter_month=filter_month,
                filter_year=filter_year,
                specific_date=specific_date
            )
            print("[REFRESH DASHBOARD] Cantidad de transacciones:", len(dashboard_data["all_transactions"]) if dashboard_data else "Sin datos")
            if dashboard_data:
                self.current_transactions = dashboard_data["all_transactions"]
                self._update_summary_panel(dashboard_data["summary"])
                self._apply_transaction_filter()
                self._update_year_selector(company_id)
                
    def _update_year_selector(self, company_id):
        """
        Obtiene los años únicos para la empresa seleccionada y actualiza el combobox de años.
        """
        unique_years = self.controller.get_unique_invoice_years(company_id)
        self.dashboard_anio_entry['values'] = unique_years
        if unique_years:
            # Opcional: seleccionar el año más reciente por defecto
            self.dashboard_anio_entry.set(unique_years[0])
        else:
            self.dashboard_anio_entry.set('')


    def _on_date_select(self, event=None):
        """Maneja el evento de selección de fecha en el calendario."""
        # Limpiar los otros filtros de fecha para evitar conflictos
        self.dashboard_mes_cb.set('')
        self.dashboard_anio_entry.set('')
        
        selected_date = self.date_filter_entry.get_date()
        self._refresh_dashboard(specific_date=selected_date)


    def _recalculate_itbis_restante(self):
        """
        Calcula el ITBIS a pagar y guarda el ITBIS adelantado en la base de datos.
        """
        try:
            adelantado_str = self.itbis_adelantado_var.get()
            itbis_adelantado = float(adelantado_str)

            # Usamos la variable de estado en lugar de leer el label
            itbis_neto = self.current_itbis_neto
            itbis_a_pagar = itbis_neto - itbis_adelantado
            
            # Actualizamos la etiqueta de resultado
            self.summary_widgets["ITBIS a Pagar"].config(
                text=f"RD${itbis_a_pagar:,.2f}",
                foreground="#C70039" if itbis_a_pagar >= 0 else "#006400"
            )
            
            # Guardamos el nuevo valor en la base de datos
            selected_name = self.company_selector_var.get()
            company_id = next((c['id'] for c in self.companies_list if c['name'] == selected_name), None)
            if company_id:
                self.controller.update_itbis_adelantado(company_id, itbis_adelantado)

        except (ValueError, TypeError):
            self.summary_widgets["ITBIS a Pagar"].config(text="Error", fg="red")



    def _open_add_emitted_window(self):
        """Abre la ventana de registro para una factura emitida (ingreso)."""
        if not self.company_selector_var.get():
            messagebox.showwarning("Sin selección", "Por favor, selecciona una empresa activa.", parent=self.root)
            return
        AddInvoiceWindow(self, self.controller, self._save_invoice_callback, 'emitida')

    def _open_add_expense_window(self):
        """Abre la ventana de registro para una factura de gasto."""
        if not self.company_selector_var.get():
            messagebox.showwarning("Sin selección", "Por favor, selecciona una empresa activa.", parent=self.root)
            return
        AddInvoiceWindow(self, self.controller, self._save_invoice_callback, 'gasto')

    def _save_invoice_callback(self, parent_window, form_data, items_data, invoice_type, invoice_id=None):
        """
        Guarda o actualiza una factura y sus ítems.
        Soporta edición aunque la ventana de modificar no pase explícitamente el invoice_id.
        CORREGIDO: Guarda la ruta del anexo en el campo 'attachment_path' para facturas de gasto.
        """
        try:
            import re

            # --- Helper numérico local ---
            def _to_float(val, default=0.0):
                if val is None:
                    return float(default)
                if isinstance(val, (int, float)):
                    return float(val)
                s = str(val).strip()
                if not s:
                    return float(default)
                s = s.replace(" ", "")
                if s.count(",") == 1 and s.count(".") > 1:
                    s = s.replace(".", "").replace(",", ".")
                elif s.count(",") == 1 and s.count(".") == 0:
                    s = s.replace(",", ".")
                try:
                    return float(s)
                except Exception:
                    return float(default)

            # --- Rescate de NCF/No. de factura si vino vacío ---
            if not (form_data.get("número_de_factura") or "").strip():
                pat_strong = re.compile(r"[A-Za-z][0-9]{6,}")  # ej. B01000000115
                numero_rescate = ""
                for name in dir(parent_window):
                    try:
                        obj = getattr(parent_window, name)
                    except Exception:
                        continue
                    if hasattr(obj, "get") and callable(getattr(obj, "get")):
                        try:
                            sval = str(obj.get() or "").strip()
                            if sval and pat_strong.search(sval):
                                numero_rescate = sval
                                break
                        except Exception:
                            pass
                if numero_rescate:
                    form_data["número_de_factura"] = numero_rescate
                    print(f"[DEBUG] RESCATE número_de_factura -> {numero_rescate!r}")

            # --- Validación mínima ---
            required_fields = {
                "número_de_factura": "Número de Factura",
                "rnc_cédula": "RNC/Cédula",
            }
            third_party_key = 'lugar_de_compra_empresa' if invoice_type == 'gasto' else 'empresa_a_la_que_se_emitió'
            required_fields[third_party_key] = "Empresa/Lugar"

            for key, nice in required_fields.items():
                if not form_data.get(key) or not str(form_data.get(key)).strip():
                    messagebox.showerror("Campo Vacío", f"El campo '{nice}' no puede estar vacío.", parent=parent_window)
                    return

            # --- Getters cortos ---
            def _g(v, default=""):
                return (form_data.get(v) or default)

            # --- Normalización de datos ---
            invoice_number   = str(_g("número_de_factura")).strip()
            rnc              = str(_g("rnc_cédula")).strip()
            third_name       = str(_g(third_party_key)).strip()
            invoice_date     = str(_g("fecha_factura", "")).strip()
            imputation_date  = str(_g("fecha_imputación", "")).strip()
            currency         = (str(_g("moneda", "RD$")).strip() or "RD$")
            invoice_category = str(_g("tipo_ncf") or _g("categoría") or "").strip()

            itbis         = _to_float(_g("itbis", 0))
            total_amount  = _to_float(_g("monto_total", 0))
            exchange_rate = _to_float(_g("tasa_cambio", 1))
            if exchange_rate <= 0:
                exchange_rate = 1.0
            total_amount_rd = round(total_amount * exchange_rate, 2)

            # --- Rescate robusto del invoice_id si estamos editando ---
            effective_invoice_id = invoice_id
            if effective_invoice_id is None:
                # nombres típicos en ventanas de edición
                for cand in ("invoice_id", "id"):
                    if hasattr(parent_window, cand):
                        try:
                            v = getattr(parent_window, cand)
                            if v:
                                effective_invoice_id = int(v)
                                break
                        except Exception:
                            pass
                # objetos/dicts comunes
                if effective_invoice_id is None:
                    for cand in ("invoice", "existing_data"):
                        obj = getattr(parent_window, cand, None)
                        if isinstance(obj, dict) and obj.get("id"):
                            try:
                                effective_invoice_id = int(obj.get("id"))
                                break
                            except Exception:
                                pass

            # --- Resolver DB y empresa activa (usando invoice_id si aplica) ---
            db = self._resolve_db()
            company_id = self._resolve_company_id(invoice_id=effective_invoice_id)
            print(f"[DEBUG] effective_invoice_id={effective_invoice_id!r}  company_id={company_id}")

            # --- Payload a BD ---
            invoice_data = {
                "company_id": company_id,
                "invoice_type": invoice_type,
                "invoice_date": invoice_date,
                "imputation_date": imputation_date or None,
                "invoice_number": invoice_number,
                "invoice_category": invoice_category,
                "rnc": rnc,
                "third_party_name": third_name,
                "currency": currency,
                "itbis": float(itbis),
                "total_amount": float(total_amount),
                "exchange_rate": float(exchange_rate),
                "total_amount_rd": float(total_amount_rd),
                "attachment_path": None  # <-- Añadido para los gastos
            }

            # --- Guardar anexo si es GASTO ---
            if invoice_type == 'gasto':
                invoice_data["attachment_path"] = None
                # Busca el StringVar de la ventana
                attachment_var = getattr(parent_window, "attachment_relative_path", None)
                if isinstance(attachment_var, str):
                    invoice_data["attachment_path"] = attachment_var
                elif attachment_var is not None and hasattr(attachment_var, "get"):
                    invoice_data["attachment_path"] = attachment_var.get()

            # --- Guardar / Actualizar ---
            if effective_invoice_id is None:
                new_id = db.add_invoice(invoice_data, items_data)
                messagebox.showinfo("Éxito", f"Factura creada (ID: {new_id}).", parent=parent_window)
            else:
                db.update_invoice(int(effective_invoice_id), invoice_data, items_data)
                messagebox.showinfo("Éxito", "Factura actualizada correctamente.", parent=parent_window)

            # --- Refrescar UI y cerrar ---
            self._refresh_dashboard()
            parent_window.destroy()

        except IntegrityError as ie:
            messagebox.showerror(
                "Duplicado",
                f"Ya existe una factura con ese Número y RNC para la empresa.\nDetalle: {ie}",
                parent=parent_window
            )
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo guardar la factura: {e}", parent=parent_window)

    def _get_selected_invoice_id(self):
        """Resuelve el ID de la factura seleccionada desde el Treeview, con trazas."""
        import re
        tree = self._resolve_invoices_tree()
        if not tree:
            self._d("_get_selected_invoice_id: NO tree")
            self._msg_error("Error", "No se encontró la tabla de facturas (Treeview).")
            return None
        try:
            sel = tree.selection()
            self._d("_get_selected_invoice_id: selection ->", sel)
            if not sel:
                self._msg_warning("Sin selección", "Seleccione una factura de la lista.")
                return None
            iid = sel[0]
            self._d("_get_selected_invoice_id: iid ->", iid)

            # ✅ CAMBIO CLAVE: usar el iid como ID de BD si es convertible a int
            try:
                return int(iid)
            except Exception:
                pass

            # (Opcional) Si en algún caso el iid no fuera el ID, ahí sí intenta otras vías:
            try:
                cols = list(tree["columns"])
                self._d("tree columns:", cols)
                if "id" in cols:
                    val = tree.set(iid, "id")
                    self._d("tree.set(iid, 'id') ->", val)
                    if val:
                        return int(val)
            except Exception as e:
                self._d("leer columna 'id' error:", e)

            # Último recurso: búsqueda por NCF (requerirá empresa activa)
            values = tree.item(iid, "values") or []
            self._d("row values:", values)
            pat = re.compile(r"[A-Za-z][0-9]{6,}")
            invoice_number = None
            for v in values:
                s = str(v).strip()
                if pat.fullmatch(s) or pat.search(s):
                    invoice_number = s
                    break
            self._d("detected invoice_number:", invoice_number)

            if not invoice_number:
                self._msg_error("Error", "No se pudo determinar el número de factura en la fila seleccionada.")
                return None

            db = self._resolve_db()
            company_id = self._resolve_company_id()
            self._d("resolving inv_id by (company_id, invoice_number):", company_id, invoice_number)
            inv_id = db.find_invoice_id_by_number(company_id, invoice_number)
            self._d("db.find_invoice_id_by_number ->", inv_id)
            if inv_id:
                return int(inv_id)

            self._msg_error("Error", "No se encontró el ID de la factura seleccionada en la base de datos.")
            return None

        except Exception as e:
            self._d("_get_selected_invoice_id error:", e)
            self._msg_error("Error", f"No se pudo obtener el ID de la factura: {e}")
            return None
    
    def _open_edit_selected_income(self):
        """Abre la ventana de Modificar Ingreso (factura emitida) pasando el invoice_id."""
        invoice_id = self._get_selected_invoice_id()
        if not invoice_id:
            return

        win = AddInvoiceWindow(
            self,
            save_callback=self._save_invoice_callback,
            invoice_type="emitida",
            invoice_id=invoice_id,           # <-- CLAVE: lo pasamos aquí
        )

        # Opcional: si quieres que la ventana tenga el dict crudo también
        db = self._resolve_db()
        row = db.get_invoice_by_id(invoice_id)
        if row:
            try:
                win.existing_data = dict(row)     # si row es sqlite3.Row
            except Exception:
                pass

        win.transient(self)
        win.grab_set()


    def _show_context_menu(self, event):
        """Muestra el menú contextual sobre la fila clickeada y habilita opciones según el registro."""
        tree = self._resolve_invoices_tree()
        if not tree:
            return

        # Seleccionar la fila bajo el cursor de click derecho
        row_iid = tree.identify_row(event.y)
        if row_iid:
            try:
                tree.selection_set(row_iid)
            except Exception:
                pass

        invoice_id = self._get_selected_invoice_id()
        if not invoice_id:
            return

        db = self._resolve_db()
        row = db.get_invoice_by_id(invoice_id)  # debes tener este helper en tu BD
        inv = self._row_to_dict(row)

        inv_type = self._row_get(inv, "invoice_type", "")
        attachment_path = self._row_get(inv, "attachment_path", "")

        # Habilitar/deshabilitar entradas del menú (ajusta los índices/nombres de tu menú)
        try:
            # Ejemplos: si tienes un tk.Menu en self.context_menu con etiquetas:
            # "Abrir Anexo", "Eliminar", "Editar", etc.
            if hasattr(self, "context_menu"):
                # Abrir anexo solo si es gasto y hay archivo
                state_attach = "normal" if (inv_type == "gasto" and attachment_path) else "disabled"
                try:
                    self.context_menu.entryconfig("Abrir Anexo", state=state_attach)
                except Exception:
                    pass
        except Exception:
            pass

        # Mostrar menú
        try:
            self.context_menu.tk_popup(event.x_root, event.y_root)
        finally:
            try:
                self.context_menu.grab_release()
            except Exception:
                pass

    def _edit_selected_invoice(self, event=None):
        """
        Abre la ventana de Modificar para la fila seleccionada, identificando
        primero el tipo de factura (ingreso o gasto) para cargar la UI correcta.
        """
        invoice_id = self._get_selected_invoice_id()
        if not invoice_id:
            return

        try:
            raw_invoice_data = self.controller.get_invoice_by_id(invoice_id)
            if not raw_invoice_data:
                self._msg_error("Error", f"No se pudo encontrar la factura con ID {invoice_id} en la base de datos.")
                return
            invoice_data = self._row_to_dict(raw_invoice_data)
        except Exception as e:
            self._msg_error("Error de Base de Datos", f"Ocurrió un error al buscar la factura: {e}")
            return
            
        invoice_type = invoice_data.get('invoice_type')
        if not invoice_type:
            self._msg_error("Error de Datos", "La transacción seleccionada no tiene un tipo definido (emitida/gasto).")
            return

        # Creamos la ventana de edición, pasando los datos existentes
        win = AddInvoiceWindow(
            self,
            self.controller,
            save_callback=self._save_invoice_callback,
            invoice_type=invoice_type,
            existing_data=invoice_data  # <-- PASAMOS EL DICT AQUÍ
        )

        win.invoice_id = invoice_id

        # Mostramos la ventana de forma modal
        if hasattr(self, "root"):
            win.transient(self.root)
        win.grab_set()

    def _delete_selected_invoice(self):
        """Elimina la factura seleccionada tras confirmación."""
        invoice_id = self._get_selected_invoice_id()
        if not invoice_id:
            messagebox.showwarning("Sin Selección", "Por favor, selecciona una factura para eliminar.", parent=self.root)
            return
            
        confirm = messagebox.askyesno(
            "Confirmar Eliminación",
            "¿Estás seguro de que deseas eliminar esta factura de forma permanente?",
            icon='warning', parent=self.root
        )
        if confirm:
            success, message = self.controller.delete_invoice(invoice_id)
            if success:
                messagebox.showinfo("Éxito", message)
                self._refresh_dashboard()
            else:
                messagebox.showerror("Error", message)


    def get_current_company_id(self):
        """Devuelve el ID de la empresa actualmente seleccionada."""
        selected_name = self.company_selector_var.get()
        return next((c['id'] for c in self.companies_list if c['name'] == selected_name), None)

    def _open_report_window(self):
        """Abre la ventana de generación de reportes."""
        if not self.company_selector_var.get():
            messagebox.showwarning("Sin selección", "Por favor, selecciona una empresa activa.", parent=self.root)
            return
        ReportWindow(self, self.controller)

    def _open_retention_calculator(self):
        """Abre la ventana de GESTIÓN de cálculos de impuestos."""
        if not self.company_selector_var.get():
            messagebox.showwarning("Sin selección", "Por favor, selecciona una empresa activa.", parent=self.root)
            return
        TaxCalculationManagementWindow(self, self.controller)
        
    def _backup_database(self):
        """Crea una copia de seguridad del archivo de la base de datos."""
        try:
            source_path = self.controller.db_path
            if not os.path.exists(source_path):
                messagebox.showerror("Error", "No se encuentra el archivo de la base de datos.", parent=self.root)
                return

            # Crear un nombre de archivo sugerido con fecha y hora
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
            filename = f"backup_{os.path.basename(source_path)}_{timestamp}.db"
            
            dest_path = filedialog.asksaveasfilename(
                title="Guardar Copia de Seguridad como...",
                initialfile=filename,
                defaultextension=".db",
                filetypes=[("Archivos de Base de Datos", "*.db"), ("Todos los archivos", "*.*")],
                parent=self.root
            )

            if dest_path:
                shutil.copy(source_path, dest_path)
                messagebox.showinfo("Éxito", f"Copia de seguridad creada exitosamente en:\n{dest_path}", parent=self.root)

        except Exception as e:
            messagebox.showerror("Error", f"No se pudo crear la copia de seguridad: {e}", parent=self.root)

    def _restore_database(self):
        """Restaura la base de datos desde un archivo de copia de seguridad."""
        confirm = messagebox.askyesno(
            "Advertencia Crítica",
            "Esta acción sobreescribirá TODOS los datos actuales con los de la copia de seguridad.\n\n"
            "¿Estás seguro de que deseas continuar? Esta acción no se puede deshacer.",
            icon='warning',
            parent=self.root
        )

        if not confirm:
            return

        try:
            backup_path = filedialog.askopenfilename(
                title="Seleccionar Copia de Seguridad para Restaurar",
                filetypes=[("Archivos de Base de Datos", "*.db"), ("Todos los archivos", "*.*")],
                parent=self.root
            )

            if backup_path:
                current_db_path = self.controller.db_path
                
                # Es crucial cerrar la conexión antes de sobreescribir el archivo
                self.controller.close_connection()
                
                shutil.copy(backup_path, current_db_path)
                
                # Reconectar y refrescar toda la aplicación
                self.controller.reconnect()
                self._populate_company_selector() # Esto recargará todo el dashboard
                
                messagebox.showinfo("Éxito", "Restauración completada. La aplicación ha sido recargada con los nuevos datos.", parent=self.root)

        except Exception as e:
            messagebox.showerror("Error de Restauración", f"No se pudo restaurar la base de datos: {e}", parent=self.root)
            # Intentar reconectar incluso si falla la restauración
            self.controller.reconnect()


    def _change_database(self):
        """Permite al usuario seleccionar un nuevo archivo de base de datos existente."""
        new_path = filedialog.askopenfilename(
            title="Abrir Base de Datos",
            filetypes=[("Base de Datos SQLite", "*.db"), ("Todos los archivos", "*.*")],
            parent=self.root
        )
        if new_path:
            self._switch_database(new_path)

    def _open_settings_window(self):
        """Abre la ventana de configuración."""
        SettingsWindow(self, self.controller)

    def _open_third_party_report_window(self):
        """Abre la ventana del reporte por terceros."""
        if not self.company_selector_var.get():
            messagebox.showwarning("Sin selección", "Por favor, selecciona una empresa activa.", parent=self.root)
            return
        ThirdPartyReportWindow(self, self.controller)

    def _switch_database(self, db_path):
        """
        Lógica central para cambiar la base de datos activa,
        recargar la UI y guardar la configuración.
        """
        try:
            # Guardar la nueva ruta en la configuración
            config_manager.set_db_path(db_path)
            
            # Actualizar el controlador con la nueva ruta y reconectar
            self.controller.db_path = db_path
            self.controller.reconnect()
            self.controller._initialize_db() # Crea las tablas si el archivo es nuevo
            
            # Limpiar y recargar toda la interfaz
            self.company_selector.set('')
            self._clear_all_filters()
            self.current_transactions = []
            self._apply_transaction_filter()
            self._update_summary_panel({"total_ingresos": 0, "itbis_ingresos": 0, "total_gastos": 0, "itbis_gastos": 0, "total_neto": 0, "itbis_neto": 0})
            self._populate_company_selector() # Recarga las empresas desde la nueva BD
            
            messagebox.showinfo("Éxito", "Se ha cargado la base de datos.", parent=self.root)
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo cargar la base de datos: {e}", parent=self.root)
        try:
            # ... (código para cambiar la BD y recargar la UI) ...
            self._populate_company_selector()
            
            messagebox.showinfo("Éxito", "Se ha cargado la base de datos.", parent=self.root)
            self._update_window_title() # <-- AÑADE ESTA LÍNEA AQUÍ
            
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo cargar la base de datos: {e}", parent=self.root)


    def _update_window_title(self):
        """Actualiza el título de la ventana para mostrar la BD activa."""
        db_name = os.path.basename(self.controller.db_path)
        self.root.title(f"Asistente de Gestión de Facturas (v2.0) - [{db_name}]")


    def _open_company_management_window(self):
        """Abre la ventana para gestionar las empresas."""
        CompanyManagementWindow(self, self.controller)


    def _open_attachment_editor(self):
        """Abre el editor para el anexo de la factura seleccionada."""
        invoice_id = self._get_selected_invoice_id()
        if not invoice_id:
            return

        invoice = self.controller.get_invoice_by_id(invoice_id)
        # Corrige aquí:
        invoice_dict = self._row_to_dict(invoice)
        relative_path = invoice_dict.get('attachment_path')

        if not relative_path:
            messagebox.showinfo("Información", "Esta factura de gasto no tiene ningún anexo guardado.", parent=self.root)
            return

        base_path = self.controller.get_attachment_base_path()
        if not base_path:
            messagebox.showerror("Error de Configuración", "La carpeta raíz de anexos no está configurada.", parent=self.root)
            return

        full_path = os.path.join(base_path, relative_path)

        if not os.path.exists(full_path):
            messagebox.showerror("Error", f"No se encontró el archivo del anexo en la ruta esperada:\n{full_path}", parent=self.root)
            return

        # Solo abrimos el editor para imágenes
        if full_path.lower().endswith(('.png', '.jpg', '.jpeg')):
            AttachmentEditorWindow(self.root, full_path)
        else:
            messagebox.showinfo("Información", f"La edición solo está disponible para imágenes.\nEste anexo es un archivo: {os.path.basename(full_path)}", parent=self.root)

    def _open_mini_calculator(self):
        """Abre la ventana de la mini calculadora."""
        MiniCalculator(self.root)


    def _open_invoice_generator(self):
        """Abre la ventana del generador de facturas."""
        company_id = self.get_current_company_id()
        if not company_id:
            messagebox.showwarning("Sin Selección", "Por favor, selecciona una empresa activa primero.", parent=self.root)
            return
        InvoiceGeneratorWindow(self.root, self.controller, company_id, main_app=self)

    def _resolve_db(self):
        """Devuelve el manejador de BD sin depender del nombre exacto del atributo."""
        for name in ("db", "database", "db_manager", "logic", "controller", "logic_controller", "model", "data"):
            obj = getattr(self, name, None)
            if obj is not None and hasattr(obj, "conn"):
                return obj
        raise RuntimeError("No hay manejador de BD accesible en MainApplication (db/database/logic/etc.).")


    def _resolve_company_id(self, invoice_id=None):
        """
        Devuelve el id de la empresa activa.
        Orden:
        1) Atributos simples (current_company_id / selected_company_id / active_company_id)
        2) Objetos empresa (dict/.id)
        3) UI (combobox o label con nombre -> BD)
        4) SETTINGS (tabla settings: active_company_id / name)
        5) EDITANDO: company_id de la factura
        6) Única empresa en BD
        """
        # 1) Atributos simples
        for name in ("current_company_id", "selected_company_id", "active_company_id"):
            if hasattr(self, name):
                try:
                    v = int(getattr(self, name))
                    if v > 0:
                        self._d(f"_resolve_company_id: por atributo {name} ->", v)
                        return v
                except Exception:
                    pass

        # 2) Objetos empresa
        for name in ("current_company", "selected_company", "active_company"):
            obj = getattr(self, name, None)
            if isinstance(obj, dict):
                try:
                    v = int(obj.get("id") or 0)
                    if v > 0:
                        self._d(f"_resolve_company_id: por objeto dict {name} ->", v)
                        return v
                except Exception:
                    pass
            elif obj is not None and hasattr(obj, "id"):
                try:
                    v = int(getattr(obj, "id"))
                    if v > 0:
                        self._d(f"_resolve_company_id: por objeto {name}.id ->", v)
                        return v
                except Exception:
                    pass

        db = self._resolve_db()

        # 3) UI: combobox / label (por nombre)
# 3) UI: combobox / label (por nombre)
        company_name = None

        # ✅ Soporte para tu combobox real
        try:
            if hasattr(self, "company_selector_var"):
                company_name = (self.company_selector_var.get() or "").strip()
                if company_name:
                    self._d("_resolve_company_id: por company_selector_var ->", company_name)
        except Exception:
            pass

        if not company_name:
            w = getattr(self, "company_selector", None)
            if w is not None and hasattr(w, "get"):
                try:
                    company_name = (w.get() or "").strip()
                    if company_name:
                        self._d("_resolve_company_id: por company_selector ->", company_name)
                except Exception:
                    pass

        if company_name:
            row = db.get_company_by_name(company_name)
            if row:
                try:
                    v = int(row["id"])
                except Exception:
                    v = int(row[0])
                self._d("_resolve_company_id: por nombre ->", v)
                return v

        # 4) SETTINGS
        cid = db.get_active_company_id_from_settings()
        if cid:
            self._d("_resolve_company_id: por settings ->", cid)
            return int(cid)

        # 5) EDITANDO: company_id de la factura
        if invoice_id is not None:
            cid = db.get_invoice_company_id(int(invoice_id))
            if cid:
                self._d("_resolve_company_id: por factura id ->", cid)
                return int(cid)

        # 6) Única empresa en BD
        only_id = db.get_single_company_id_or_none()
        if only_id:
            self._d("_resolve_company_id: única empresa en BD ->", only_id)
            return int(only_id)

        raise RuntimeError("No hay empresa activa seleccionada. Selecciona una empresa antes de guardar.")

    def _row_to_dict(self, row):
        """Convierte sqlite3.Row o tuplas a dict seguro."""
        try:
            if row is None:
                return {}
            if isinstance(row, dict):
                return row
            if hasattr(row, "keys"):  # sqlite3.Row
                return {k: row[k] for k in row.keys()}
        except Exception:
            pass
        return {}

    def _row_get(self, row, key, default=None):
        """Obtiene una clave de dict o sqlite3.Row sin romper."""
        try:
            if isinstance(row, dict):
                return row.get(key, default)
            if hasattr(row, "keys"):
                return row[key] if key in row.keys() else default
        except Exception:
            pass
        return default


    def _resolve_invoices_tree(self):
        """Localiza el Treeview de facturas por nombre común, por tipo, o buscándolo en el árbol de widgets."""
        # 1) Nombres comunes
        for name in ("tree_invoices", "treeInvoices", "treeview_invoices", "tv_invoices", "tree", "tv"):
            w = getattr(self, name, None)
            if isinstance(w, ttk.Treeview):
                self._d("_resolve_invoices_tree: encontrado por nombre ->", name)
                return w

        # 2) Buscar en atributos del objeto
        for k, v in self.__dict__.items():
            if isinstance(v, ttk.Treeview):
                self._d("_resolve_invoices_tree: encontrado en __dict__ ->", k)
                return v

        # 3) Búsqueda profunda desde self.root
        def _find_tv(widget):
            try:
                for ch in widget.winfo_children():
                    if isinstance(ch, ttk.Treeview):
                        return ch
                    r = _find_tv(ch)
                    if r:
                        return r
            except Exception:
                pass
            return None

        root = getattr(self, "root", None)
        if root:
            tv = _find_tv(root)
            if tv:
                self._d("_resolve_invoices_tree: encontrado por búsqueda profunda")
                return tv

        self._d("_resolve_invoices_tree: NO se encontró Treeview")
        return None


    # Wrappers para messagebox con parent seguro (usa self.root si existe)
    def _msg_error(self, title, text):
        parent = getattr(self, "root", None)
        try:
            from tkinter import messagebox
            messagebox.showerror(title, text, parent=parent if parent else None)
        except Exception:
            from tkinter import messagebox
            messagebox.showerror(title, text)

    def _msg_warning(self, title, text):
        parent = getattr(self, "root", None)
        try:
            from tkinter import messagebox
            messagebox.showwarning(title, text, parent=parent if parent else None)
        except Exception:
            from tkinter import messagebox
            messagebox.showwarning(title, text)

    def _msg_info(self, title, text):
        parent = getattr(self, "root", None)
        try:
            from tkinter import messagebox
            messagebox.showinfo(title, text, parent=parent if parent else None)
        except Exception:
            from tkinter import messagebox
            messagebox.showinfo(title, text)
# ======================== DEBUG HELPERS ========================
    def _d(self, *args):
        try:
            print("[DEBUG]", *args, flush=True)
        except Exception:
            pass

    # ===================== ENLACES (BIND) A EVENTOS =====================
    def bind_edit_actions(self):
        """Conecta doble-click y click derecho del Treeview de facturas con debug."""
        tree = self._resolve_invoices_tree()
        if not tree:
            self._d("bind_edit_actions: NO se encontró el Treeview de facturas.")
            return

        # Doble click
        tree.bind("<Double-1>", self._on_invoice_tree_double_click, add="+")
        # Click derecho (Windows/Linux)
        tree.bind("<Button-3>", self._on_invoice_tree_right_click, add="+")
        # (Opcional macOS): tree.bind("<Button-2>", self._on_invoice_tree_right_click, add="+")

        self._d("bind_edit_actions: Binds listos en", repr(tree))

    # ===================== HANDLERS CON PRINTS =====================
    def _on_invoice_tree_double_click(self, event):
        tree = self._resolve_invoices_tree()
        self._d("DOUBLE-CLICK fired:", {"x": event.x, "y": event.y, "x_root": event.x_root, "y_root": event.y_root})
        if not tree:
            self._d("_on_invoice_tree_double_click: NO tree")
            return

        region = tree.identify("region", event.x, event.y)
        row_iid = tree.identify_row(event.y)
        col_id  = tree.identify_column(event.x)
        self._d("double-click region:", region, "row_iid:", row_iid, "col:", col_id)

        if row_iid:
            try:
                tree.selection_set(row_iid)
                tree.focus(row_iid)
            except Exception as e:
                self._d("double-click set selection error:", e)

        inv_id = self._get_selected_invoice_id()  # este método también lo ajusto con prints abajo
        self._d("double-click -> selected invoice_id:", inv_id)
        if inv_id:
            # abre la edición (puedes llamar a tu método existente)
            self._edit_selected_invoice()  # este a su vez vuelve a pedir el id, OK por ahora


    def _on_invoice_tree_right_click(self, event):
        tree = self._resolve_invoices_tree()
        self._d("RIGHT-CLICK fired:", {"x": event.x, "y": event.y, "x_root": event.x_root, "y_root": event.y_root})
        if not tree:
            self._d("_on_invoice_tree_right_click: NO tree")
            return

        row_iid = tree.identify_row(event.y)
        self._d("right-click row_iid under cursor:", row_iid)
        if row_iid:
            try:
                tree.selection_set(row_iid)
                tree.focus(row_iid)
            except Exception as e:
                self._d("right-click set selection error:", e)

        inv_id = self._get_selected_invoice_id()
        self._d("right-click -> selected invoice_id:", inv_id)

        # Si tienes ctx_menu, lo mostramos
        if hasattr(self, "ctx_menu"):
            try:
                self._d("ctx_menu.tk_popup at", event.x_root, event.y_root)
                self.ctx_menu.tk_popup(event.x_root, event.y_root)
            finally:
                try:
                    self.ctx_menu.grab_release()
                except Exception:
                    pass
        else:
            self._d("No ctx_menu definido; nada que mostrar.")


    def _on_company_changed(self, event=None):
        w = getattr(self, "combo_company", None)  # ajusta al nombre real de tu combobox
        if not w or not hasattr(w, "get"):
            return
        name = (w.get() or "").strip()
        if not name:
            return
        db = self._resolve_db()
        row = db.get_company_by_name(name)
        if row:
            try:
                cid = int(row["id"])
            except Exception:
                cid = int(row[0])
            # guarda en settings
            cur = db.conn.cursor()
            cur.execute("INSERT INTO settings(key,value) VALUES('active_company_id', ?) ON CONFLICT(key) DO UPDATE SET value=excluded.value", (str(cid),))
            db.conn.commit()
            self._d("Empresa activa guardada en settings ->", cid)


### Archivo: attachment_editor_window.py

# Archivo: attachment_editor_window.py (Fase 3: Herramienta de Recorte)

import tkinter as tk
from tkinter import ttk, messagebox
from PIL import Image, ImageTk, ImageEnhance
import os
from invoice_generator_window import NCF_TYPES
from invoice_generator_window import ITBIS_RATE
import invoice_filler
ITBIS_RATE = 0.18

NCF_TYPES = {
    "Crédito Fiscal (B01)": "B01",
    "Consumidor Final (B02)": "B02",
    "Gubernamental (B15)": "B15",
    "Régimen Especial (B14)": "B14",
    "Nota de Crédito (B04)": "B04",
}
class AttachmentEditorWindow(tk.Toplevel):
    def __init__(self, parent, image_path):
        super().__init__(parent)
        self.image_path = image_path
        self.original_image = None
        self.current_image = None
        self.photo_image = None

        # Variables para Zoom y Pan
        self.zoom_level = 1.0
        self.max_zoom = 5.0
        self.min_zoom = 0.1
        self.image_id_on_canvas = None
        self._drag_data = {"x": 0, "y": 0}

        # Variables para Recortar
        self.crop_mode = False
        self.crop_start_x = 0
        self.crop_start_y = 0
        self.crop_end_x = 0
        self.crop_end_y = 0
        self.crop_rectangle_id = None

        self.history = []
        self.history_index = -1

        self.title("Visor / Editor de Anexos")
        self.geometry("800x700")
        
        self.icons = self._load_icons()
        self._build_ui()
        self._load_and_display_image() # <-- La línea que daba error ahora encontrará su método

        # Bindings para el mouse
        self.canvas.bind("<MouseWheel>", self._on_mouse_wheel)
        self.canvas.bind("<ButtonPress-1>", self._on_button_press)
        self.canvas.bind("<B1-Motion>", self._on_mouse_drag)
        self.canvas.bind("<ButtonRelease-1>", self._on_button_release)

    def _load_icons(self):
        icon_names = ["rotate_left", "rotate_right", "contrast", "crop", "save", "undo", "redo", "reset"]
        icons = {}
        for name in icon_names:
            try:
                path = os.path.join("icons", f"{name}.png")
                img = Image.open(path).resize((24, 24), Image.Resampling.LANCZOS)
                icons[name] = ImageTk.PhotoImage(img)
            except FileNotFoundError:
                print(f"Advertencia: No se encontró el icono 'icons/{name}.png'")
                icons[name] = None
        return icons

    def _build_ui(self):
        toolbar = ttk.Frame(self, padding=5)
        toolbar.pack(side=tk.TOP, fill=tk.X)
        
        ttk.Button(toolbar, image=self.icons.get("undo"), command=self._undo).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, image=self.icons.get("redo"), command=self._redo).pack(side=tk.LEFT, padx=2)
        ttk.Separator(toolbar, orient='vertical').pack(side=tk.LEFT, padx=10, fill='y')
        ttk.Button(toolbar, image=self.icons.get("rotate_left"), command=lambda: self._rotate_image(90)).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, image=self.icons.get("rotate_right"), command=lambda: self._rotate_image(-90)).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, image=self.icons.get("contrast"), command=self._enhance_contrast).pack(side=tk.LEFT, padx=2)
        
        self.crop_button = ttk.Button(toolbar, image=self.icons.get("crop"), command=self._toggle_crop_mode)
        self.crop_button.pack(side=tk.LEFT, padx=2)
        
        self.apply_crop_button = ttk.Button(toolbar, text="Aplicar Recorte", command=self._apply_crop, style="Accent.TButton")
        self.cancel_crop_button = ttk.Button(toolbar, text="Cancelar", command=self._toggle_crop_mode)

        ttk.Separator(toolbar, orient='vertical').pack(side=tk.LEFT, padx=10, fill='y')
        ttk.Button(toolbar, image=self.icons.get("reset"), command=self._reset_view).pack(side=tk.LEFT, padx=2)
        ttk.Button(toolbar, text="Guardar Cambios", image=self.icons.get("save"), compound="left", style="Accent.TButton", command=self._save_changes).pack(side=tk.RIGHT, padx=10)

        self.canvas = tk.Canvas(self, bg="#7f7f7f")
        self.canvas.pack(fill=tk.BOTH, expand=True)
        
    def _load_and_display_image(self):
        """Carga la imagen original desde el disco y la muestra."""
        try:
            self.original_image = Image.open(self.image_path)
            self.current_image = self.original_image.copy()
            self._update_display()
        except Exception as e:
            messagebox.showerror("Error al Cargar Imagen", f"No se pudo abrir el archivo:\n{e}", parent=self)
            self.destroy()

    def _update_display(self):
        """Prepara y muestra la imagen actual en el canvas, aplicando el zoom."""
        if not self.current_image: return
        new_width = int(self.original_image.width * self.zoom_level)
        new_height = int(self.original_image.height * self.zoom_level)
        resized_image = self.current_image.resize((new_width, new_height), Image.Resampling.LANCZOS)
        self.photo_image = ImageTk.PhotoImage(resized_image)
        self.canvas.delete("all")
        canvas_w = self.canvas.winfo_width()
        canvas_h = self.canvas.winfo_height()
        self.image_id_on_canvas = self.canvas.create_image(canvas_w / 2, canvas_h / 2, anchor=tk.CENTER, image=self.photo_image)
        self.crop_rectangle_id = None

    def _reset_view(self):
        """Recarga la imagen original y resetea el zoom y el modo recorte."""
        if self.crop_mode:
            self._toggle_crop_mode()
        self.zoom_level = 1.0
        self._load_and_display_image()

    def _on_mouse_wheel(self, event):
        if self.crop_mode: return # No hacer zoom en modo recorte
        if event.delta > 0 or event.num == 4: self.zoom_level *= 1.1
        elif event.delta < 0 or event.num == 5: self.zoom_level /= 1.1
        self.zoom_level = max(self.min_zoom, min(self.max_zoom, self.zoom_level))
        self._update_display()

    def _on_button_press(self, event):
        if self.crop_mode:
            self.crop_start_x = event.x
            self.crop_start_y = event.y
            if self.crop_rectangle_id: self.canvas.delete(self.crop_rectangle_id)
            self.crop_rectangle_id = self.canvas.create_rectangle(self.crop_start_x, self.crop_start_y, self.crop_start_x, self.crop_start_y, outline="red", width=2, dash=(4, 4))
        else:
            self.canvas.config(cursor="fleur")
            self._drag_data["x"] = event.x
            self._drag_data["y"] = event.y

    def _on_mouse_drag(self, event):
        if self.crop_mode:
            self.crop_end_x = event.x
            self.crop_end_y = event.y
            self.canvas.coords(self.crop_rectangle_id, self.crop_start_x, self.crop_start_y, self.crop_end_x, self.crop_end_y)
        else:
            delta_x = event.x - self._drag_data["x"]
            delta_y = event.y - self._drag_data["y"]
            self.canvas.move(self.image_id_on_canvas, delta_x, delta_y)
            self._drag_data["x"] = event.x
            self._drag_data["y"] = event.y
    
    def _on_button_release(self, event):
        if self.crop_mode:
            self.crop_end_x = event.x
            self.crop_end_y = event.y
        else:
            self.canvas.config(cursor="")
            
    def _toggle_crop_mode(self):
        self.crop_mode = not self.crop_mode
        if self.crop_mode:
            self.canvas.config(cursor="crosshair")
            self.apply_crop_button.pack(side=tk.LEFT, padx=(10, 2))
            self.cancel_crop_button.pack(side=tk.LEFT, padx=2)
        else:
            self.canvas.config(cursor="")
            if self.crop_rectangle_id: self.canvas.delete(self.crop_rectangle_id)
            self.crop_rectangle_id = None
            self.apply_crop_button.pack_forget()
            self.cancel_crop_button.pack_forget()

    def _apply_crop(self):
        if not self.crop_rectangle_id:
            messagebox.showwarning("Sin Selección", "Dibuja un rectángulo en la imagen primero.", parent=self)
            return
        
        x1, y1, x2, y2 = self.canvas.coords(self.crop_rectangle_id)
        box_x1, box_y1 = min(x1, x2), min(y1, y2)
        box_x2, box_y2 = max(x1, x2), max(y1, y2)

        img_coords = self.canvas.coords(self.image_id_on_canvas)
        img_x, img_y = img_coords[0], img_coords[1]
        
        img_w_on_canvas = self.photo_image.width()
        img_h_on_canvas = self.photo_image.height()
        
        canvas_img_x1 = img_x - img_w_on_canvas / 2
        canvas_img_y1 = img_y - img_h_on_canvas / 2
        
        crop_x1 = max(0, box_x1 - canvas_img_x1)
        crop_y1 = max(0, box_y1 - canvas_img_y1)
        crop_x2 = min(img_w_on_canvas, box_x2 - canvas_img_x1)
        crop_y2 = min(img_h_on_canvas, box_y2 - canvas_img_y1)
        
        if crop_x1 >= crop_x2 or crop_y1 >= crop_y2:
            self._toggle_crop_mode()
            return

        scale_factor = self.current_image.width / img_w_on_canvas
        
        final_crop_box = (
            int(crop_x1 * scale_factor), int(crop_y1 * scale_factor),
            int(crop_x2 * scale_factor), int(crop_y2 * scale_factor)
        )

        self.current_image = self.current_image.crop(final_crop_box)
        self.original_image = self.current_image.copy()

        self._toggle_crop_mode()
        self.zoom_level = 1.0
        self._update_display()
        
    def _rotate_image(self, angle):
        if self.current_image:
            self.current_image = self.current_image.rotate(angle, expand=True)
            self._update_display()
            
    def _enhance_contrast(self):
        if self.current_image:
            enhancer = ImageEnhance.Contrast(self.current_image)
            self.current_image = enhancer.enhance(1.5)
            self._update_display()

    def _undo(self): messagebox.showinfo("Próximamente", "La función de deshacer se implementará en la fase final.", parent=self)
    def _redo(self): messagebox.showinfo("Próximamente", "La función de rehacer se implementará en la fase final.", parent=self)

    def _save_changes(self):
        if self.current_image:
            try:
                save_image = self.current_image # Guardamos la versión actual
                if save_image.mode == 'RGBA': save_image = save_image.convert('RGB')
                save_image.save(self.image_path, quality=95, optimize=True)
                self.original_image = self.current_image.copy() # La versión guardada es ahora la original
                messagebox.showinfo("Guardado", "Los cambios han sido guardados.", parent=self)
            except Exception as e:
                messagebox.showerror("Error al Guardar", f"No se pudo guardar el archivo:\n{e}", parent=self)

# ... el resto igual ...

    def _generate(self):
        client_name = self.client_name.get()
        client_rnc = self.client_rnc.get()
        invoice_ncf = self.ncf_number_var.get()
        if not all([client_name, client_rnc, invoice_ncf]):
            messagebox.showerror("Datos Faltantes", "Los datos del cliente y el NCF son requeridos.", parent=self)
            return
        if not self.items_tree.get_children():
            messagebox.showerror("Sin Detalles", "Debes agregar al menos un detalle a la factura.", parent=self)
            return
            
        ncf_type_prefix = NCF_TYPES.get(self.ncf_type_var.get())
        output_dir = self.controller.get_invoice_output_path(self.company_id, ncf_type_prefix)
        if not output_dir:
            return
            
        company_details = self.controller.get_company_details(self.company_id)
        items = []
        for item_id in self.items_tree.get_children():
            values = self.items_tree.item(item_id, 'values')
            items.append({
                'description': values[0],
                'quantity': float(values[1].replace(",", "")),
                'unit_price': float(values[2].replace(",", "")),
                'subtotal': float(values[3].replace(",", ""))
            })
        
        invoice_data = {
            "company_id": self.company_id,
            "invoice_type": "emitida",
            "invoice_date": self.invoice_date.get_date().strftime("%Y-%m-%d"),
            "imputation_date": None,
            "invoice_number": invoice_ncf,
            "invoice_category": ncf_type_prefix,
            "rnc": client_rnc,
            "third_party_name": client_name,
            "currency": "RD$",  # Puedes adaptar si manejas otra moneda
            "itbis": sum(i['subtotal'] for i in items) * ITBIS_RATE if self.apply_itbis.get() else 0.0,
            "total_amount": sum(i['subtotal'] for i in items),
            "exchange_rate": 1.0,
            "total_amount_rd": sum(i['subtotal'] for i in items) + (sum(i['subtotal'] for i in items) * ITBIS_RATE if self.apply_itbis.get() else 0.0),
            "attachment_path": "",  # Puedes llenar si lo necesitas
        }
        
        # Para el Excel
        excel_invoice_data = {
            "company_name": company_details['name'],
            "company_rnc": company_details['rnc'],
            "company_address": company_details.get('address', ''),
            "client_name": client_name,
            "client_rnc": client_rnc,
            "invoice_date": self.invoice_date.get_date(),
            "invoice_ncf": invoice_ncf,
            "invoice_due_date": self.invoice_due_date.get_date(),
            "items": items,
            "apply_itbis": self.apply_itbis.get()
        }
        
        safe_client_name = "".join(c for c in client_name if c.isalnum() or c in " .-_").rstrip()
        output_filename = f"Factura {invoice_ncf} - {safe_client_name}.xlsx"
        output_path = os.path.join(output_dir, output_filename)
        
        invoice_filler.fill_invoice_template(self.company_template_path, output_path, excel_invoice_data)

        # ---- REGISTRA LA FACTURA EN LA BD ----
        try:
            factura_id = self.controller.add_invoice(invoice_data, [])
            if factura_id:
                # Pregunta si quiere abrir el archivo
                if messagebox.askyesno("Factura creada", f"Factura creada correctamente en:\n{output_path}\n\n¿Desea abrirla?", parent=self):
                    os.startfile(output_path)
            else:
                messagebox.showerror("Error", "No se pudo registrar la factura en la base de datos.", parent=self)
        except Exception as e:
            messagebox.showerror("Error", f"No se pudo registrar la factura en la base de datos:\n{e}", parent=self)

### Archivo: report_generator.py

# report_generator.py (Versión Completa con Logs de Depuración)

import os
import io
import pandas as pd
from fpdf import FPDF
from PIL import Image
from pypdf import PdfWriter, PdfReader
import tempfile

class PDF(FPDF):
    """Clase heredada de FPDF para crear encabezados y pies de página personalizados."""
    def __init__(self, orientation='P', unit='mm', format='A4', company_name="", report_title="", report_period=""):
        super().__init__(orientation, unit, format)
        self.company_name = company_name
        self.report_title = report_title
        self.report_period = report_period
        self.set_auto_page_break(auto=True, margin=15)
        self.alias_nb_pages()

    def header(self):
        self.set_font('Arial', 'B', 14)
        self.cell(0, 10, self.report_title, 0, 1, 'C')
        self.set_font('Arial', 'I', 11)
        self.cell(0, 8, f'Empresa: {self.company_name}', 0, 1, 'C')
        self.cell(0, 6, f'Período: {self.report_period}', 0, 1, 'C')
        self.ln(10)

    def footer(self):
        self.set_y(-15)
        self.set_font('Arial', 'I', 8)
        self.cell(0, 10, f'Página {self.page_no()}/{{nb}}', 0, 0, 'C')

def generate_professional_pdf(report_data, save_path, company_name, month, year, attachment_base_path):
    temp_files = []
    try:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_report:
            temp_report_path = temp_report.name
            temp_files.append(temp_report_path)

        pdf_report = PDF(orientation='L', company_name=company_name, report_title="Reporte Mensual de Facturación", report_period=f"{month}/{year}")
        pdf_report.add_page()
        
        HEADER_BG_COLOR = (220, 220, 220)
        ROW_BG_COLOR_ALT = (245, 245, 245)
        pdf_report.set_font('Arial', 'B', 12)
        pdf_report.cell(0, 10, 'Resumen General del Mes (en RD$)', 0, 1, 'L')
        summary = report_data['summary']

        # Ajuste para tamaño carta horizontal y líneas separadas
        page_width = pdf_report.w - 2 * pdf_report.l_margin
        col_width = page_width / 2
        line_height = 7
        pdf_report.set_font('Arial', '', 10)
        pdf_report.cell(col_width, line_height, f"Total Ingresos: RD$ {summary.get('total_ingresos', 0.0):,.2f}", border=0)
        pdf_report.cell(col_width, line_height, f"ITBIS Ingresos: RD$ {summary.get('itbis_ingresos', 0.0):,.2f}", border=0, ln=1, align='R')
        pdf_report.cell(col_width, line_height, f"Total Gastos: RD$ {summary.get('total_gastos', 0.0):,.2f}", border=0)
        pdf_report.cell(col_width, line_height, f"ITBIS Gastos: RD$ {summary.get('itbis_gastos', 0.0):,.2f}", border=0, ln=1, align='R')
        pdf_report.set_font('Arial', 'B', 10)
        pdf_report.cell(col_width, line_height, f"Total Neto: RD$ {summary.get('total_neto', 0.0):,.2f}", border='T')
        pdf_report.cell(col_width, line_height, f"ITBIS Neto: RD$ {summary.get('itbis_neto', 0.0):,.2f}", border='T', ln=1, align='R')
        pdf_report.ln(10)

        # Función para dibujar tablas con anchos calculados
        def draw_table(title, headers, data, column_widths_percent):
            pdf_report.set_font('Arial', 'B', 12)
            pdf_report.cell(0, 10, title, 0, 1, 'L')
            pdf_report.set_font('Arial', 'B', 9)
            pdf_report.set_fill_color(*HEADER_BG_COLOR)
            page_width = pdf_report.w - 2 * pdf_report.l_margin
            column_widths = [(w / 100.0) * page_width for w in column_widths_percent]
            for i, header in enumerate(headers):
                pdf_report.cell(column_widths[i], 8, header, 1, 0, 'C', 1)
            pdf_report.ln()
            pdf_report.set_font('Arial', '', 8)
            fill = False
            for row in data:
                pdf_report.set_fill_color(*ROW_BG_COLOR_ALT) if fill else pdf_report.set_fill_color(255, 255, 255)
                for i, datum in enumerate(row):
                    pdf_report.cell(column_widths[i], 6, str(datum), 1, 0, 'L' if i < 3 else 'R', 1)
                pdf_report.ln()
                fill = not fill

        headers_emitted = ['Fecha', 'No. Fact.', 'Empresa', 'ITBIS (RD$)', 'Total (RD$)']
        data_emitted = [[f['invoice_date'], f['invoice_number'], f['third_party_name'], f"{f['itbis'] * f['exchange_rate']:,.2f}", f"{f['total_amount_rd']:,.2f}"] for f in report_data['emitted_invoices']]
        # Los porcentajes deben sumar 100 y ser apropiados para tamaño carta horizontal
        draw_table('Facturas Emitidas (Ingresos)', headers_emitted, data_emitted, [17, 17, 40, 13, 13])
        pdf_report.ln(10)
        headers_expenses = ['Fecha', 'No. Fact.', 'Empresa', 'ITBIS (RD$)', 'Total (RD$)']
        data_expenses = [[f['invoice_date'], f['invoice_number'], f['third_party_name'], f"{f['itbis'] * f['exchange_rate']:,.2f}", f"{f['total_amount_rd']:,.2f}"] for f in report_data['expense_invoices']]
        draw_table('Facturas de Gastos', headers_expenses, data_expenses, [17, 17, 40, 13, 13])
        
        pdf_report.output(temp_report_path)

        merger = PdfWriter()
        merger.append(temp_report_path)

        attachments_to_process = report_data.get('ordered_attachments', 
                                                 [f for f in report_data['expense_invoices'] if f.get('attachment_path')])

        if attachments_to_process and attachment_base_path:
            for invoice in attachments_to_process:
                relative_path = invoice['attachment_path']
                full_path = os.path.join(attachment_base_path, relative_path)

                if os.path.exists(full_path):
                    if full_path.lower().endswith('.pdf'):
                        merger.append(full_path)
                    
                    elif full_path.lower().endswith(('.png', '.jpg', '.jpeg')):
                        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_img:
                            temp_img_path = temp_img.name
                            temp_files.append(temp_img_path)
                        
                        pdf_img = PDF(orientation='P', company_name=company_name, report_title="Anexo de Comprobante", report_period=f"Factura: {invoice['invoice_number']}")
                        pdf_img.add_page()
                        y_position = pdf_img.get_y()
                        
                        with Image.open(full_path) as img:
                            img_w, img_h = img.size
                            aspect_ratio = img_w / img_h
                            printable_width = pdf_img.w - 2 * pdf_img.l_margin
                            display_w = printable_width
                            display_h = display_w / aspect_ratio
                            
                            available_height = pdf_img.h - y_position - pdf_img.b_margin
                            if display_h > available_height:
                                display_h = available_height
                                display_w = display_h * aspect_ratio
                        
                        pdf_img.image(full_path, x=pdf_img.l_margin, y=y_position, w=display_w, h=display_h)
                        pdf_img.output(temp_img_path)
                        merger.append(temp_img_path)

        with open(save_path, "wb") as f_out:
            merger.write(f_out)

        return True, "Reporte PDF con anexos generado exitosamente."

    except Exception as e:
        return False, f"No se pudo generar el PDF: {e}"
    finally:
        for temp_file in temp_files:
            try:
                os.remove(temp_file)
            except OSError:
                pass

def generate_excel_report(report_data, save_path):
    """Genera un reporte mensual en formato Excel."""
    try:
        summary_totals = report_data["summary"]
        resumen_data = {
            "Descripción": ["Total Ingresos (RD$)", "Total ITBIS Ingresos (RD$)", "Total Gastos (RD$)", "Total ITBIS Gastos (RD$)", "ITBIS Neto (RD$)", "Total Neto (RD$)"],
            "Monto": [summary_totals.get("total_ingresos", 0.0), summary_totals.get("itbis_ingresos", 0.0), summary_totals.get("total_gastos", 0.0), summary_totals.get("itbis_gastos", 0.0), summary_totals.get("itbis_neto", 0.0), summary_totals.get("total_neto", 0.0)]
        }
        df_resumen = pd.DataFrame(resumen_data)
        df_ingresos = pd.DataFrame(report_data["emitted_invoices"])
        df_gastos = pd.DataFrame(report_data["expense_invoices"])

        with pd.ExcelWriter(save_path, engine='openpyxl') as writer:
            df_resumen.to_excel(writer, sheet_name='Resumen', index=False)
            df_ingresos.to_excel(writer, sheet_name='Ingresos', index=False)
            df_gastos.to_excel(writer, sheet_name='Gastos', index=False)

        return True, "Reporte Excel generado exitosamente."
    except Exception as e:
        return False, f"No se pudo generar el Excel: {e}"

def generate_retention_pdf(save_path, company_name, period_str, results_data, selected_invoices):
    """Genera un PDF profesional para el cálculo de retenciones."""
    try:
        pdf = PDF(orientation='P', company_name=company_name, report_title="Cálculo de Retenciones", report_period=period_str)
        pdf.add_page()
        
        pdf.set_font('Arial', 'B', 12)
        pdf.cell(0, 10, f"Base del Cálculo ({results_data['num_invoices']} facturas seleccionadas)", 0, 1, 'L')
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 7, f"Total General Seleccionado: RD$ {results_data['total_general_rd']:,.2f}", 0, 1, 'L')
        pdf.cell(0, 7, f"Total ITBIS Seleccionado: RD$ {results_data['total_itbis_rd']:,.2f}", 0, 1, 'L')
        pdf.cell(0, 7, f"Total Subtotal Seleccionado: RD$ {results_data['total_subtotal_rd']:,.2f}", 0, 1, 'L')
        pdf.ln(5)

        pdf.set_font('Arial', 'B', 12)
        pdf.cell(0, 10, "Resultados de Retenciones", 0, 1, 'L')
        pdf.set_font('Arial', '', 10)
        pdf.cell(0, 7, f"Retención del {results_data['p_itb']:.2f}% del ITBIS: RD$ {results_data['ret_itbis']:,.2f}", 0, 1, 'L')
        pdf.cell(0, 7, f"Retención del {results_data['p_tot']:.2f}% del Total: RD$ {results_data['ret_total']:,.2f}", 0, 1, 'L')
        pdf.ln(5)
        
        pdf.set_font('Arial', 'B', 13)
        pdf.set_fill_color(220, 220, 220)
        pdf.cell(0, 10, f"TOTAL A RETENER: RD$ {results_data['total_a_retener']:,.2f}", border=1, ln=1, align='C', fill=True)
        pdf.ln(10)

        pdf.set_font('Arial', 'B', 12)
        pdf.cell(0, 10, "Facturas Incluidas en el Cálculo", 0, 1, 'L')
        
        pdf.set_font('Arial', 'B', 9)
        pdf.cell(25, 7, "Fecha", 1, 0, 'C'); pdf.cell(40, 7, "No. Factura", 1, 0, 'C'); pdf.cell(85, 7, "Empresa", 1, 0, 'C'); pdf.cell(30, 7, "Total (RD$)", 1, 1, 'C')

        pdf.set_font('Arial', '', 8)
        for inv in selected_invoices:
            pdf.cell(25, 6, inv['invoice_date'], 1, 0, 'L')
            pdf.cell(40, 6, inv['invoice_number'], 1, 0, 'L')
            pdf.cell(85, 6, inv['third_party_name'][:50], 1, 0, 'L')
            pdf.cell(30, 6, f"{inv['total_amount_rd']:,.2f}", 1, 1, 'R')
            
        pdf.output(save_path)
        return True, "Reporte de retenciones generado exitosamente."
    except Exception as e:
        return False, f"No se pudo generar el PDF de retenciones: {e}"
    
def generate_advanced_retention_pdf(save_path, company_name, period_str, summary_data, selected_invoices):
    """Genera un PDF para el cálculo avanzado de impuestos, mostrando valores originales y convertidos."""
    try:
        pdf = PDF(orientation='L', company_name=company_name, report_title="Reporte de Cálculo de Impuestos", report_period=period_str)
        pdf.add_page()
        
        pdf.set_font('Arial', 'B', 12)
        pdf.cell(0, 10, "Facturas Incluidas en el Cálculo", 0, 1, 'L')
        
        # <<-- CAMBIO: Nuevas columnas y anchos para la tabla detallada -->>
        pdf.set_font('Arial', 'B', 8)
        pdf.set_fill_color(220, 220, 220)
        
        # Anchos de columna optimizados para A4 horizontal
        col_widths = [20, 30, 70, 12, 15, 25, 25, 25, 25]
        headers = ['Fecha', 'No. Factura', 'Empresa', 'Mon.', 'Tasa', 'Total (Orig)', 'Total (RD$)', 'Impuestos (Orig)', 'Impuestos (RD$)']
        
        for i, header in enumerate(headers):
            ln = 1 if i == len(headers) - 1 else 0
            pdf.cell(col_widths[i], 7, header, 1, ln, 'C', 1)

        pdf.set_font('Arial', '', 7)
        currency_symbols = {'USD': '$', 'EUR': '€', 'RD$': 'RD$'}
        fill = False
        
        # <<-- CAMBIO: Llenar la tabla con los nuevos datos -->>
        for inv in selected_invoices:
            pdf.set_fill_color(245, 245, 245) if fill else pdf.set_fill_color(255, 255, 255)
            
            symbol = currency_symbols.get(inv['currency'], inv['currency'])
            
            # Formatear valores
            total_orig_str = f"{symbol} {inv['total_orig']:,.2f}"
            total_rd_str = f"RD$ {inv['total_rd']:,.2f}"
            imp_orig_str = f"{symbol} {inv['total_imp_orig']:,.2f}"
            imp_rd_str = f"RD$ {inv['total_imp_rd']:,.2f}"

            pdf.cell(col_widths[0], 6, inv['fecha'], 1, 0, 'L', 1)
            pdf.cell(col_widths[1], 6, inv['no_fact'], 1, 0, 'L', 1)
            pdf.cell(col_widths[2], 6, inv['empresa'][:45], 1, 0, 'L', 1) # Acortar nombre de empresa si es largo
            pdf.cell(col_widths[3], 6, inv['currency'], 1, 0, 'C', 1)
            pdf.cell(col_widths[4], 6, f"{inv['exchange_rate']:.2f}", 1, 0, 'R', 1)
            pdf.cell(col_widths[5], 6, total_orig_str, 1, 0, 'R', 1)
            pdf.cell(col_widths[6], 6, total_rd_str, 1, 0, 'R', 1)
            pdf.cell(col_widths[7], 6, imp_orig_str, 1, 0, 'R', 1)
            pdf.cell(col_widths[8], 6, imp_rd_str, 1, 1, 'R', 1)
            fill = not fill

        # --- El Resumen Final no cambia y ya es compatible con la nueva lógica ---
        pdf.ln(10)
        pdf.set_font('Arial', 'B', 12)
        pdf.cell(0, 10, "Resumen del Cálculo", 0, 1, 'L')
        
        pdf.set_font('Arial', '', 11)
        pdf.cell(90, 8, f"Cálculo basado en {len(selected_invoices)} facturas seleccionadas.", 0, 1)
        pdf.cell(90, 8, f"Porcentaje aplicado sobre el total: {summary_data['percent_to_pay']}%", 0, 1)
        
        pdf.set_font('Arial', 'B', 11)
        pdf.cell(90, 8, "Totales por Moneda de Origen:", 0, 1)
        pdf.set_font('Arial', '', 11)
        
        currency_totals = summary_data.get('currency_totals', {})
        for currency, total in sorted(currency_totals.items()):
            symbol = currency_symbols.get(currency, currency)
            pdf.cell(90, 8, f"   - Suma Total Impuestos ({currency}): {symbol} {total:,.2f}", 0, 1)

        pdf.ln(5)
        pdf.set_font('Arial', 'B', 14)
        pdf.set_fill_color(220, 220, 220)
        grand_total = summary_data.get('grand_total_rd', 0.0)
        pdf.cell(0, 12, f"GRAN TOTAL (CONVERTIDO A RD$): RD$ {grand_total:,.2f}", 1, 1, 'C', 1)

        pdf.output(save_path)
        return True, "Reporte de impuestos y retenciones generado exitosamente."
    except Exception as e:
        import traceback
        traceback.print_exc()
        return False, f"No se pudo generar el PDF: {e}"

Nuestro flujo de trabajo será el siguiente:
1.  Yo te presentaré Las mejoras que quiero hacer
2.  Tú analizarás mi petición en el contexto del código que te he proporcionado.
3.  Me proporcionarás el código completo y corregido para los métodos o clases que necesiten ser modificados, explicando los cambios de forma clara y concisa.
4.  Yo implementaré tus sugerencias y te informaré del resultado o de cualquier nuevo error para que podamos solucionarlo.
5. Nuestro Objetivo Tambien sera adaptar los dashbard que hoy tenemos a unas nuevas ventanas que pienso disenar en Pyqt6 y me vas a ayudar a adaptarlo